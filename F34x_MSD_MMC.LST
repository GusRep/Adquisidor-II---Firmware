C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE F34X_MSD_MMC
OBJECT MODULE PLACED IN F34x_MSD_MMC.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F34x_MSD_MMC.c PW(80) SB LC OT(9,SI
                    -ZE) CD DB OE DF(__F340_VER__) LARGE

line level    source

   1          //----------------------------------------------------------------
             --------------
   2          // F34x_MSD_MMC.c
   3          //----------------------------------------------------------------
             --------------
   4          // Copyright 2006 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // MMC FLASH is used for storing the log entries.  Each entry cont
             -ains
  10          // the temperature in hundredths of a degree C, the day, hour, min
             -ute, and
  11          // second that the reading was taken.  The LogUpdate function stor
             -es log
  12          // entries in an external memory buffer and then writes that buffe
             -r out to the
  13          // MMC when it is full.  Communication with the MMC is performed t
             -hrough the 
  14          // MMC access functions.  These functions provide transparent MMC 
             -access to 
  15          // the higher level functions (Logging functions).  The MMC interf
             -ace is broken
  16          // into two pieces.  The high level piece consists of the user cal
             -lable MMC
  17          // access functions (MMC_FLASH_Read, MMC_FLASH_Write, MMC_FLASH_Cl
             -ear, 
  18          // MMC_FLASH_MassErase).  These functions are called by the user t
             -o execute
  19          // data operations on the MMC.  They break down the data operation
             -s into MMC
  20          // commands.  The low level piece consists of a single command exe
             -cution
  21          // function (MMC_Command_Exec) which is called by the MMC data man
             -ipulation
  22          // functions.  This function is called every time a command must b
             -e sent to the
  23          // MMC.  It handles all of the required SPI traffic between the Si
             -licon 
  24          // Laboratories device and the MMC.
  25          //
  26          //
  27          // How To Test:    See Readme.txt
  28          //
  29          //
  30          // FID:            34X000043
  31          // Target:         C8051F34x
  32          // Tool chain:     Keil
  33          // Command Line:   See Readme.txt
  34          // Project Name:   F34x_USB_MSD
  35          //
  36          // Release 1.1
  37          //    -All changes by PKC
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 2   

  38          //    -09 JUN 2006
  39          //    -Replaced SFR definitions file "c8051f320.h" with "c8051f340
             -.h"
  40          //    -Corrected "SPIDAT" to "SPI0DAT" in function Write_Read_Spi_
             -Byte
  41          //
  42          // Release 1.0
  43          //    -Initial Release
  44          //
  45          
  46          
  47          //----------------------------------------------------------------
             --------------
  48          // Includes
  49          //----------------------------------------------------------------
             --------------
  50          
  51          #include "F34x_MSD_Definitions.h"
   1      =1  //----------------------------------------------------------------
             --------------
   2      =1  // F34x_MSD_Definitions.h
   3      =1  //----------------------------------------------------------------
             --------------
   4      =1  // Copyright 2006 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Header file with all definitions.
  10      =1  //
  11      =1  //
  12      =1  // FID:            34X000032
  13      =1  // Target:         C8051F34x
  14      =1  // Tool chain:     Keil
  15      =1  // Command Line:   See Readme.txt
  16      =1  // Project Name:   F34x_USB_MSD
  17      =1  //
  18      =1  // Release 1.1
  19      =1  //    -All changes by PKC
  20      =1  //    -09 JUN 2006
  21      =1  //    -Replaced SFR definitions file "c8051f320.h" with "c8051f340
             -.h"
  22      =1  //
  23      =1  // Release 1.0
  24      =1  //    -Initial Release
  25      =1  //
  26      =1  
  27      =1  //----------------------------------------------------------------
             --------------
  28      =1  // Header File Preprocessor Directive
  29      =1  //----------------------------------------------------------------
             --------------
  30      =1  
  31      =1  #ifndef __DEFINITIONS_H__
  32      =1  #define __DEFINITIONS_H__
  33      =1  
  34      =1  #define DEBUG_TIMEOUTS
  35      =1  #include "c8051f340.h"
   1      =2  //----------------------------------------------------------------
             --------------
   2      =2  // C8051F340.h
   3      =2  //----------------------------------------------------------------
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 3   

             --------------
   4      =2  // Copyright 2005 Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F34x family.
  10      =2  //
  11      =2  //
  12      =2  // FID:            34X000002
  13      =2  // Target:         C8051F340, 'F341, 'F342, 'F343, 'F344, 'F345, '
             -F346, 'F347
  14      =2  // Tool chain:     Keil
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 1.0
  18      =2  //    -Initial Release (GP\PKC)
  19      =2  //    -13 DEC 2005
  20      =2  
  21      =2  //----------------------------------------------------------------
             --------------
  22      =2  // Header File Preprocessor Directive
  23      =2  //----------------------------------------------------------------
             --------------
  24      =2  
  25      =2  #ifndef C8051F340_H
  26      =2  #define C8051F340_H
  27      =2  
  28      =2  //----------------------------------------------------------------
             --------------
  29      =2  // Byte Registers
  30      =2  //----------------------------------------------------------------
             --------------
  31      =2  
  32      =2  sfr  P0           =  0x80;             // Port 0 Latch
  33      =2  sfr  SP           =  0x81;             // Stack Pointer
  34      =2  sfr  DPL          =  0x82;             // Data Pointer Low
  35      =2  sfr  DPH          =  0x83;             // Data Pointer High
  36      =2  sfr  EMI0TC       =  0x84;             // EMIF Timing
  37      =2  sfr  EMI0CF       =  0x85;             // EMIF Configuration
  38      =2  sfr  OSCLCN       =  0x86;             // Internal Low-Freq Oscill
             -ator Control
  39      =2  sfr  PCON         =  0x87;             // Power Control
  40      =2  sfr  TCON         =  0x88;             // Timer/Counter Control
  41      =2  sfr  TMOD         =  0x89;             // Timer/Counter Mode
  42      =2  sfr  TL0          =  0x8A;             // Timer/Counter 0 Low
  43      =2  sfr  TL1          =  0x8B;             // Timer/Counter 1 Low
  44      =2  sfr  TH0          =  0x8C;             // Timer/Counter 0 High
  45      =2  sfr  TH1          =  0x8D;             // Timer/Counter 1 High
  46      =2  sfr  CKCON        =  0x8E;             // Clock Control
  47      =2  sfr  PSCTL        =  0x8F;             // Program Store R/W Contro
             -l
  48      =2  sfr  P1           =  0x90;             // Port 1 Latch
  49      =2  sfr  TMR3CN       =  0x91;             // Timer/Counter 3Control
  50      =2  sfr  TMR3RLL      =  0x92;             // Timer/Counter 3 Reload L
             -ow
  51      =2  sfr  TMR3RLH      =  0x93;             // Timer/Counter 3 Reload H
             -igh
  52      =2  sfr  TMR3L        =  0x94;             // Timer/Counter 3Low
  53      =2  sfr  TMR3H        =  0x95;             // Timer/Counter 3 High
  54      =2  sfr  USB0ADR      =  0x96;             // USB0 Indirect Address Re
             -gister
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 4   

  55      =2  sfr  USB0DAT      =  0x97;             // USB0 Data Register
  56      =2  sfr  SCON0        =  0x98;             // UART0 Control
  57      =2  sfr  SBUF0        =  0x99;             // UART0 Data Buffer
  58      =2  sfr  CPT1CN       =  0x9A;             // Comparator1 Control
  59      =2  sfr  CPT0CN       =  0x9B;             // Comparator0 Control
  60      =2  sfr  CPT1MD       =  0x9C;             // Comparator1 Mode Selecti
             -on
  61      =2  sfr  CPT0MD       =  0x9D;             // Comparator0 Mode Selecti
             -on
  62      =2  sfr  CPT1MX       =  0x9E;             // Comparator1 MUX Selectio
             -n
  63      =2  sfr  CPT0MX       =  0x9F;             // Comparator0 MUX Selectio
             -n
  64      =2  sfr  P2           =  0xA0;             // Port 2 Latch
  65      =2  sfr  SPI0CFG      =  0xA1;             // SPI Configuration
  66      =2  sfr  SPI0CKR      =  0xA2;             // SPI Clock Rate Control
  67      =2  sfr  SPI0DAT      =  0xA3;             // SPI Data
  68      =2  sfr  P0MDOUT      =  0xA4;             // Port 0 Output Mode Confi
             -guration
  69      =2  sfr  P1MDOUT      =  0xA5;             // Port 1 Output Mode Confi
             -guration
  70      =2  sfr  P2MDOUT      =  0xA6;             // Port 2 Output Mode Confi
             -guration
  71      =2  sfr  P3MDOUT      =  0xA7;             // Port 3 Output Mode Confi
             -guration
  72      =2  sfr  IE           =  0xA8;             // Interrupt Enable
  73      =2  sfr  CLKSEL       =  0xA9;             // Clock Select
  74      =2  sfr  EMI0CN       =  0xAA;             // External Memory Interfac
             -e Control
  75      =2  sfr  SBCON1       =  0xAC;             // UART1 Baud Rate Generato
             -r Control
  76      =2  sfr  P4MDOUT      =  0xAE;             // Port 4 Output Mode Confi
             -guration
  77      =2  sfr  PFE0CN       =  0xAF;             // Prefetch Engine Control
  78      =2  sfr  P3           =  0xB0;             // Port 3 Latch
  79      =2  sfr  OSCXCN       =  0xB1;             // External Oscillator Cont
             -rol
  80      =2  sfr  OSCICN       =  0xB2;             // Internal Oscillator Cont
             -rol
  81      =2  sfr  OSCICL       =  0xB3;             // Internal Oscillator Cali
             -bration
  82      =2  sfr  SBRLL1       =  0xB4;             // UART1 Baud Rate Generato
             -r Low
  83      =2  sfr  SBRLH1       =  0xB5;             // UART1 Baud Rate Generato
             -r High
  84      =2  sfr  FLSCL        =  0xB6;             // Flash Scale
  85      =2  sfr  FLKEY        =  0xB7;             // Flash Lock and Key
  86      =2  sfr  IP           =  0xB8;             // Interrupt Priority
  87      =2  sfr  CLKMUL       =  0xB9;             // Clock Multiplier
  88      =2  sfr  AMX0N        =  0xBA;             // AMUX0 Negative Channel S
             -elect
  89      =2  sfr  AMX0P        =  0xBB;             // AMUX0 Positive Channel S
             -elect
  90      =2  sfr  ADC0CF       =  0xBC;             // ADC0 Configuration
  91      =2  sfr  ADC0L        =  0xBD;             // ADC0 Low
  92      =2  sfr  ADC0H        =  0xBE;             // ADC0 High
  93      =2  sfr  SMB0CN       =  0xC0;             // SMBus Control
  94      =2  sfr  SMB0CF       =  0xC1;             // SMBus Configuration
  95      =2  sfr  SMB0DAT      =  0xC2;             // SMBus Data
  96      =2  sfr  ADC0GTL      =  0xC3;             // ADC0 Greater-Than Compar
             -e Low
  97      =2  sfr  ADC0GTH      =  0xC4;             // ADC0 Greater-Than Compar
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 5   

             -e High
  98      =2  sfr  ADC0LTL      =  0xC5;             // ADC0 Less-Than Compare W
             -ord Low
  99      =2  sfr  ADC0LTH      =  0xC6;             // ADC0 Less-Than Compare W
             -ord High
 100      =2  sfr  P4           =  0xC7;             // Port 4 Latch
 101      =2  sfr  TMR2CN       =  0xC8;             // Timer/Counter 2 Control
 102      =2  sfr  REG0CN       =  0xC9;             // Voltage Regulator Contro
             -l
 103      =2  sfr  TMR2RLL      =  0xCA;             // Timer/Counter 2 Reload L
             -ow
 104      =2  sfr  TMR2RLH      =  0xCB;             // Timer/Counter 2 Reload H
             -igh
 105      =2  sfr  TMR2L        =  0xCC;             // Timer/Counter 2 Low
 106      =2  sfr  TMR2H        =  0xCD;             // Timer/Counter 2 High
 107      =2  sfr  PSW          =  0xD0;             // Program Status Word
 108      =2  sfr  REF0CN       =  0xD1;             // Voltage Reference Contro
             -l
 109      =2  sfr  SCON1        =  0xD2;             // UART1 Control
 110      =2  sfr  SBUF1        =  0xD3;             // UART1 Data Buffer
 111      =2  sfr  P0SKIP       =  0xD4;             // Port 0 Skip
 112      =2  sfr  P1SKIP       =  0xD5;             // Port 1 Skip
 113      =2  sfr  P2SKIP       =  0xD6;             // Port 2 Skip
 114      =2  sfr  USB0XCN      =  0xD7;             // USB0 Transceiver Control
 115      =2  sfr  PCA0CN       =  0xD8;             // PCA0 Control
 116      =2  sfr  PCA0MD       =  0xD9;             // PCA0 Mode
 117      =2  sfr  PCA0CPM0     =  0xDA;             // PCA0 Module 0 Mode Regis
             -ter
 118      =2  sfr  PCA0CPM1     =  0xDB;             // PCA0 Module 1 Mode Regis
             -ter
 119      =2  sfr  PCA0CPM2     =  0xDC;             // PCA0 Module 2 Mode Regis
             -ter
 120      =2  sfr  PCA0CPM3     =  0xDD;             // PCA0 Module 3 Mode Regis
             -ter
 121      =2  sfr  PCA0CPM4     =  0xDE;             // PCA0 Module 4 Mode Regis
             -ter
 122      =2  sfr  P3SKIP       =  0xDF;             // Port 3 Skip
 123      =2  sfr  ACC          =  0xE0;             // Accumulator
 124      =2  sfr  XBR0         =  0xE1;             // Port I/O Crossbar Contro
             -l 0
 125      =2  sfr  XBR1         =  0xE2;             // Port I/O Crossbar Contro
             -l 1
 126      =2  sfr  XBR2         =  0xE3;             // Port I/O Crossbar Contro
             -l 2
 127      =2  sfr  IT01CF       =  0xE4;             // INT0/INT1 Configuration
 128      =2  sfr  SMOD1        =  0xE5;             // UART1 Mode
 129      =2  sfr  EIE1         =  0xE6;             // Extended Interrupt Enabl
             -e 1
 130      =2  sfr  EIE2         =  0xE7;             // Extended Interrupt Enabl
             -e 2
 131      =2  sfr  ADC0CN       =  0xE8;             // ADC0 Control
 132      =2  sfr  PCA0CPL1     =  0xE9;             // PCA0 Capture 1 Low
 133      =2  sfr  PCA0CPH1     =  0xEA;             // PCA0 Capture 1 High
 134      =2  sfr  PCA0CPL2     =  0xEB;             // PCA0 Capture 2 Low
 135      =2  sfr  PCA0CPH2     =  0xEC;             // PCA0 Capture 2 High
 136      =2  sfr  PCA0CPL3     =  0xED;             // PCA0 Capture 3 Low
 137      =2  sfr  PCA0CPH3     =  0xEE;             // PCA0 Capture 3 High
 138      =2  sfr  RSTSRC       =  0xEF;             // Reset Source Configurati
             -on/Status
 139      =2  sfr  B            =  0xF0;             // B Register
 140      =2  sfr  P0MDIN       =  0xF1;             // Port 0 Input Mode Config
             -uration
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 6   

 141      =2  sfr  P1MDIN       =  0xF2;             // Port 1 Input Mode Config
             -uration
 142      =2  sfr  P2MDIN       =  0xF3;             // Port 2 Input Mode Config
             -uration
 143      =2  sfr  P3MDIN       =  0xF4;             // Port 3 Input Mode Config
             -uration
 144      =2  sfr  P4MDIN       =  0xF5;             // Port 4 Input Mode Config
             -uration
 145      =2  sfr  EIP1         =  0xF6;             // Extended Interrupt Prior
             -ity 1
 146      =2  sfr  EIP2         =  0xF7;             // Extended Interrupt Prior
             -ity 2
 147      =2  sfr  SPI0CN       =  0xF8;             // SPI0 Control
 148      =2  sfr  PCA0L        =  0xF9;             // PCA0 Counter Low
 149      =2  sfr  PCA0H        =  0xFA;             // PCA0 Counter High
 150      =2  sfr  PCA0CPL0     =  0xFB;             // PCA0 Capture 0 Low
 151      =2  sfr  PCA0CPH0     =  0xFC;             // PCA0 Capture 0 High
 152      =2  sfr  PCA0CPL4     =  0xFD;             // PCA0 Capture 4 Low
 153      =2  sfr  PCA0CPH4     =  0xFE;             // PCA0 Capture 4 High
 154      =2  sfr  VDM0CN       =  0xFF;             // VDD Monitor Control
 155      =2  
 156      =2  
 157      =2  //----------------------------------------------------------------
             --------------
 158      =2  // Bit Definitions
 159      =2  //----------------------------------------------------------------
             --------------
 160      =2  
 161      =2  // TCON 0x88
 162      =2  sbit TF1     = 0x8F;                   // Timer1 overflow flag
 163      =2  sbit TR1     = 0x8E;                   // Timer1 on/off control
 164      =2  sbit TF0     = 0x8D;                   // Timer0 overflow flag
 165      =2  sbit TR0     = 0x8C;                   // Timer0 on/off control
 166      =2  sbit IE1     = 0x8B;                   // Ext interrupt 1 edge fla
             -g
 167      =2  sbit IT1     = 0x8A;                   // Ext interrupt 1 type
 168      =2  sbit IE0     = 0x89;                   // Ext interrupt 0 edge fla
             -g
 169      =2  sbit IT0     = 0x88;                   // Ext interrupt 0 type
 170      =2  
 171      =2  // SCON0 0x98
 172      =2  sbit S0MODE  = 0x9F;                   // Serial mode control bit 
             -0
 173      =2                                         // Bit6 UNUSED
 174      =2  sbit MCE0    = 0x9D;                   // Multiprocessor communica
             -tion enable
 175      =2  sbit REN0    = 0x9C;                   // Receive enable
 176      =2  sbit TB80    = 0x9B;                   // Transmit bit 8
 177      =2  sbit RB80    = 0x9A;                   // Receive bit 8
 178      =2  sbit TI0     = 0x99;                   // Transmit interrupt flag
 179      =2  sbit RI0     = 0x98;                   // Receive interrupt flag
 180      =2  
 181      =2  // IE 0xA8
 182      =2  sbit EA      = 0xAF;                   // Global interrupt enable
 183      =2  sbit ESPI0   = 0xAE;                   // SPI0 interrupt enable
 184      =2  sbit ET2     = 0xAD;                   // Timer2 interrupt enable
 185      =2  sbit ES0     = 0xAC;                   // UART0 interrupt enable
 186      =2  sbit ET1     = 0xAB;                   // Timer1 interrupt enable
 187      =2  sbit EX1     = 0xAA;                   // External interrupt 1 ena
             -ble
 188      =2  sbit ET0     = 0xA9;                   // Timer0 interrupt enable
 189      =2  sbit EX0     = 0xA8;                   // External interrupt 0 ena
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 7   

             -ble
 190      =2  
 191      =2  // IP 0xB8
 192      =2                                         // Bit7 UNUSED
 193      =2  sbit PSPI0   = 0xBE;                   // SPI0 interrupt priority
 194      =2  sbit PT2     = 0xBD;                   // Timer2 priority
 195      =2  sbit PS0     = 0xBC;                   // UART0 priority
 196      =2  sbit PT1     = 0xBB;                   // Timer1 priority
 197      =2  sbit PX1     = 0xBA;                   // External interrupt 1 pri
             -ority
 198      =2  sbit PT0     = 0xB9;                   // Timer0 priority
 199      =2  sbit PX0     = 0xB8;                   // External interrupt 0 pri
             -ority
 200      =2  
 201      =2  // SMB0CN 0xC0
 202      =2  sbit MASTER  = 0xC7;                   // Master/slave indicator
 203      =2  sbit TXMODE  = 0xC6;                   // Transmit mode indicator
 204      =2  sbit STA     = 0xC5;                   // Start flag
 205      =2  sbit STO     = 0xC4;                   // Stop flag
 206      =2  sbit ACKRQ   = 0xC3;                   // Acknowledge request
 207      =2  sbit ARBLOST = 0xC2;                   // Arbitration lost indicat
             -or
 208      =2  sbit ACK     = 0xC1;                   // Acknowledge flag
 209      =2  sbit SI      = 0xC0;                   // SMBus interrupt flag
 210      =2  
 211      =2  // TMR2CN 0xC8
 212      =2  sbit TF2H    = 0xCF;                   // Timer2 high byte overflo
             -w flag
 213      =2  sbit TF2L    = 0xCE;                   // Timer2 low byte overflow
             - flag
 214      =2  sbit TF2LEN  = 0xCD;                   // Timer2 low byte interrup
             -t enable
 215      =2  sbit T2CE    = 0xCC;                   // Timer2 capture enable
 216      =2  sbit T2SPLIT = 0xCB;                   // Timer2 split mode enable
 217      =2  sbit TR2     = 0xCA;                   // Timer2 on/off control
 218      =2  sbit T2CSS   = 0xC9;                   // Timer 2 Capture Source s
             -elect
 219      =2  sbit T2XCLK  = 0xC8;                   // Timer2 external clock se
             -lect
 220      =2  
 221      =2  // PSW 0xD0
 222      =2  sbit CY      = 0xD7;                   // Carry flag
 223      =2  sbit AC      = 0xD6;                   // Auxiliary carry flag
 224      =2  sbit F0      = 0xD5;                   // User flag 0
 225      =2  sbit RS1     = 0xD4;                   // Register bank select 1
 226      =2  sbit RS0     = 0xD3;                   // Register bank select 0
 227      =2  sbit OV      = 0xD2;                   // Overflow flag
 228      =2  sbit F1      = 0xD1;                   // User flag 1
 229      =2  sbit P       = 0xD0;                   // Accumulator parity flag
 230      =2  
 231      =2  // PCA0CN 0xD8
 232      =2  sbit CF      = 0xDF;                   // PCA0 counter overflow fl
             -ag
 233      =2  sbit CR      = 0xDE;                   // PCA0 counter run control
 234      =2                                         // Bit5 UNUSED
 235      =2  sbit CCF4    = 0xDC;                   // PCA0 module4 capture/com
             -pare flag
 236      =2  sbit CCF3    = 0xDB;                   // PCA0 module3 capture/com
             -pare flag
 237      =2  sbit CCF2    = 0xDA;                   // PCA0 module2 capture/com
             -pare flag
 238      =2  sbit CCF1    = 0xD9;                   // PCA0 module1 capture/com
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 8   

             -pare flag
 239      =2  sbit CCF0    = 0xD8;                   // PCA0 module0 capture/com
             -pare flag
 240      =2  
 241      =2  // ADC0CN 0xE8
 242      =2  sbit AD0EN   = 0xEF;                   // ADC0 enable
 243      =2  sbit AD0TM   = 0xEE;                   // ADC0 track mode
 244      =2  sbit AD0INT  = 0xED;                   // ADC0 conversion complete
             - interrupt flag
 245      =2  sbit AD0BUSY = 0xEC;                   // ADC0 busy flag
 246      =2  sbit AD0WINT = 0xEB;                   // ADC0 window compare inte
             -rrupt flag
 247      =2  sbit AD0CM2  = 0xEA;                   // ADC0 conversion mode sel
             -ect 2
 248      =2  sbit AD0CM1  = 0xE9;                   // ADC0 conversion mode sel
             -ect 1
 249      =2  sbit AD0CM0  = 0xE8;                   // ADC0 conversion mode sel
             -ect 0
 250      =2  
 251      =2  // SPI0CN 0xF8
 252      =2  sbit SPIF    = 0xFF;                   // SPI0 interrupt flag
 253      =2  sbit WCOL    = 0xFE;                   // SPI0 write collision fla
             -g
 254      =2  sbit MODF    = 0xFD;                   // SPI0 mode fault flag
 255      =2  sbit RXOVRN  = 0xFC;                   // SPI0 rx overrun flag
 256      =2  sbit NSSMD1  = 0xFB;                   // SPI0 slave select mode 1
 257      =2  sbit NSSMD0  = 0xFA;                   // SPI0 slave select mode 0
 258      =2  sbit TXBMT   = 0xF9;                   // SPI0 transmit buffer emp
             -ty
 259      =2  sbit SPIEN   = 0xF8;                   // SPI0 SPI enable
 260      =2  
 261      =2  
 262      =2  //----------------------------------------------------------------
             --------------
 263      =2  // Interrupt Priorities
 264      =2  //----------------------------------------------------------------
             --------------
 265      =2  
 266      =2  #define INTERRUPT_INT0             0   // External Interrupt 0
 267      =2  #define INTERRUPT_TIMER0           1   // Timer0 Overflow
 268      =2  #define INTERRUPT_INT1             2   // External Interrupt 1
 269      =2  #define INTERRUPT_TIMER1           3   // Timer1 Overflow
 270      =2  #define INTERRUPT_UART0            4   // Serial Port 0
 271      =2  #define INTERRUPT_TIMER2           5   // Timer2 Overflow
 272      =2  #define INTERRUPT_SPI0             6   // Serial Peripheral Interf
             -ace 0
 273      =2  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 274      =2  #define INTERRUPT_USB0             8   // USB Interface
 275      =2  #define INTERRUPT_ADC0_WINDOW      9   // ADC0 Window Comparison
 276      =2  #define INTERRUPT_ADC0_EOC         10  // ADC0 End Of Conversion
 277      =2  #define INTERRUPT_PCA0             11  // PCA0 Peripheral
 278      =2  #define INTERRUPT_COMPARATOR0      12  // Comparator0
 279      =2  #define INTERRUPT_COMPARATOR1      13  // Comparator1
 280      =2  #define INTERRUPT_TIMER3           14  // Timer3 Overflow
 281      =2  #define INTERRUPT_VBUS_LEVEL       15  // VBUS level-triggered int
             -errupt
 282      =2  #define INTERRUPT_UART1            16  // Serial Port 1
 283      =2  
 284      =2  //----------------------------------------------------------------
             --------------
 285      =2  // Header File PreProcessor Directive
 286      =2  //----------------------------------------------------------------
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 9   

             --------------
 287      =2  
 288      =2  #endif                                 // #define C8051F340_H
 289      =2  
 290      =2  //----------------------------------------------------------------
             --------------
 291      =2  // End Of File
 292      =2  //----------------------------------------------------------------
             --------------
  36      =1  #ifdef DEBUG_TIMEOUTS
  37      =1  sbit START_STOP_SPI = P3^0 ;
  38      =1  sbit START_STOP_READ_TO = P3^1;
  39      =1  sbit START_STOP_WRITE_TO = P3^2;
  40      =1  
  41      =1  #define START_SPI_TIMEOUT (START_STOP_SPI = 1)
  42      =1  #define STOP_SPI_TIME_OUT (START_STOP_SPI = 0)
  43      =1  #define START_READ_COPY (START_STOP_READ_TO = 1)
  44      =1  #define STOP_READ_COPY (START_STOP_READ_TO = 0)
  45      =1  #define START_WRITE_COPY (START_STOP_WRITE_TO = 1)
  46      =1  #define STOP_WRITE_COPY (START_STOP_WRITE_TO = 0)
  47      =1  #else
           =1 
           =1 #define START_SPI_TIMEOUT /\
           =1 /
           =1 #define STOP_SPI_TIME_OUT /\
           =1 /
           =1 #define START_READ_COPY /\
           =1 /
           =1 #define STOP_READ_COPY /\
           =1 /
           =1 #define START_WRITE_COPY /\
           =1 /
           =1 #define STOP_WRITE_COPY /\
           =1 /
           =1 
           =1 #endif
  63      =1  
  64      =1  #define ENDLINE         "\r\n"
  65      =1  #define ENDLINE_SGN '\r'
  66      =1  
  67      =1  #endif
  52          #include "c8051f340.h"                 // SFR declarations
   1      =1  //----------------------------------------------------------------
             --------------
   2      =1  // C8051F340.h
   3      =1  //----------------------------------------------------------------
             --------------
   4      =1  // Copyright 2005 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F34x family.
  10      =1  //
  11      =1  //
  12      =1  // FID:            34X000002
  13      =1  // Target:         C8051F340, 'F341, 'F342, 'F343, 'F344, 'F345, '
             -F346, 'F347
  14      =1  // Tool chain:     Keil
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 1.0
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 10  

  18      =1  //    -Initial Release (GP\PKC)
  19      =1  //    -13 DEC 2005
  20      =1  
  21      =1  //----------------------------------------------------------------
             --------------
  22      =1  // Header File Preprocessor Directive
  23      =1  //----------------------------------------------------------------
             --------------
  24      =1  
  25      =1  #ifndef C8051F340_H
           =1 #define C8051F340_H
           =1 
           =1 //----------------------------------------------------------------
             --------------
           =1 // Byte Registers
           =1 //----------------------------------------------------------------
             --------------
           =1 
           =1 sfr  P0           =  0x80;             // Port 0 Latch
           =1 sfr  SP           =  0x81;             // Stack Pointer
           =1 sfr  DPL          =  0x82;             // Data Pointer Low
           =1 sfr  DPH          =  0x83;             // Data Pointer High
           =1 sfr  EMI0TC       =  0x84;             // EMIF Timing
           =1 sfr  EMI0CF       =  0x85;             // EMIF Configuration
           =1 sfr  OSCLCN       =  0x86;             // Internal Low-Freq Oscill
             -ator Control
           =1 sfr  PCON         =  0x87;             // Power Control
           =1 sfr  TCON         =  0x88;             // Timer/Counter Control
           =1 sfr  TMOD         =  0x89;             // Timer/Counter Mode
           =1 sfr  TL0          =  0x8A;             // Timer/Counter 0 Low
           =1 sfr  TL1          =  0x8B;             // Timer/Counter 1 Low
           =1 sfr  TH0          =  0x8C;             // Timer/Counter 0 High
           =1 sfr  TH1          =  0x8D;             // Timer/Counter 1 High
           =1 sfr  CKCON        =  0x8E;             // Clock Control
           =1 sfr  PSCTL        =  0x8F;             // Program Store R/W Contro
             -l
           =1 sfr  P1           =  0x90;             // Port 1 Latch
           =1 sfr  TMR3CN       =  0x91;             // Timer/Counter 3Control
           =1 sfr  TMR3RLL      =  0x92;             // Timer/Counter 3 Reload L
             -ow
           =1 sfr  TMR3RLH      =  0x93;             // Timer/Counter 3 Reload H
             -igh
           =1 sfr  TMR3L        =  0x94;             // Timer/Counter 3Low
           =1 sfr  TMR3H        =  0x95;             // Timer/Counter 3 High
           =1 sfr  USB0ADR      =  0x96;             // USB0 Indirect Address Re
             -gister
           =1 sfr  USB0DAT      =  0x97;             // USB0 Data Register
           =1 sfr  SCON0        =  0x98;             // UART0 Control
           =1 sfr  SBUF0        =  0x99;             // UART0 Data Buffer
           =1 sfr  CPT1CN       =  0x9A;             // Comparator1 Control
           =1 sfr  CPT0CN       =  0x9B;             // Comparator0 Control
           =1 sfr  CPT1MD       =  0x9C;             // Comparator1 Mode Selecti
             -on
           =1 sfr  CPT0MD       =  0x9D;             // Comparator0 Mode Selecti
             -on
           =1 sfr  CPT1MX       =  0x9E;             // Comparator1 MUX Selectio
             -n
           =1 sfr  CPT0MX       =  0x9F;             // Comparator0 MUX Selectio
             -n
           =1 sfr  P2           =  0xA0;             // Port 2 Latch
           =1 sfr  SPI0CFG      =  0xA1;             // SPI Configuration
           =1 sfr  SPI0CKR      =  0xA2;             // SPI Clock Rate Control
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 11  

           =1 sfr  SPI0DAT      =  0xA3;             // SPI Data
           =1 sfr  P0MDOUT      =  0xA4;             // Port 0 Output Mode Confi
             -guration
           =1 sfr  P1MDOUT      =  0xA5;             // Port 1 Output Mode Confi
             -guration
           =1 sfr  P2MDOUT      =  0xA6;             // Port 2 Output Mode Confi
             -guration
           =1 sfr  P3MDOUT      =  0xA7;             // Port 3 Output Mode Confi
             -guration
           =1 sfr  IE           =  0xA8;             // Interrupt Enable
           =1 sfr  CLKSEL       =  0xA9;             // Clock Select
           =1 sfr  EMI0CN       =  0xAA;             // External Memory Interfac
             -e Control
           =1 sfr  SBCON1       =  0xAC;             // UART1 Baud Rate Generato
             -r Control
           =1 sfr  P4MDOUT      =  0xAE;             // Port 4 Output Mode Confi
             -guration
           =1 sfr  PFE0CN       =  0xAF;             // Prefetch Engine Control
           =1 sfr  P3           =  0xB0;             // Port 3 Latch
           =1 sfr  OSCXCN       =  0xB1;             // External Oscillator Cont
             -rol
           =1 sfr  OSCICN       =  0xB2;             // Internal Oscillator Cont
             -rol
           =1 sfr  OSCICL       =  0xB3;             // Internal Oscillator Cali
             -bration
           =1 sfr  SBRLL1       =  0xB4;             // UART1 Baud Rate Generato
             -r Low
           =1 sfr  SBRLH1       =  0xB5;             // UART1 Baud Rate Generato
             -r High
           =1 sfr  FLSCL        =  0xB6;             // Flash Scale
           =1 sfr  FLKEY        =  0xB7;             // Flash Lock and Key
           =1 sfr  IP           =  0xB8;             // Interrupt Priority
           =1 sfr  CLKMUL       =  0xB9;             // Clock Multiplier
           =1 sfr  AMX0N        =  0xBA;             // AMUX0 Negative Channel S
             -elect
           =1 sfr  AMX0P        =  0xBB;             // AMUX0 Positive Channel S
             -elect
           =1 sfr  ADC0CF       =  0xBC;             // ADC0 Configuration
           =1 sfr  ADC0L        =  0xBD;             // ADC0 Low
           =1 sfr  ADC0H        =  0xBE;             // ADC0 High
           =1 sfr  SMB0CN       =  0xC0;             // SMBus Control
           =1 sfr  SMB0CF       =  0xC1;             // SMBus Configuration
           =1 sfr  SMB0DAT      =  0xC2;             // SMBus Data
           =1 sfr  ADC0GTL      =  0xC3;             // ADC0 Greater-Than Compar
             -e Low
           =1 sfr  ADC0GTH      =  0xC4;             // ADC0 Greater-Than Compar
             -e High
           =1 sfr  ADC0LTL      =  0xC5;             // ADC0 Less-Than Compare W
             -ord Low
           =1 sfr  ADC0LTH      =  0xC6;             // ADC0 Less-Than Compare W
             -ord High
           =1 sfr  P4           =  0xC7;             // Port 4 Latch
           =1 sfr  TMR2CN       =  0xC8;             // Timer/Counter 2 Control
           =1 sfr  REG0CN       =  0xC9;             // Voltage Regulator Contro
             -l
           =1 sfr  TMR2RLL      =  0xCA;             // Timer/Counter 2 Reload L
             -ow
           =1 sfr  TMR2RLH      =  0xCB;             // Timer/Counter 2 Reload H
             -igh
           =1 sfr  TMR2L        =  0xCC;             // Timer/Counter 2 Low
           =1 sfr  TMR2H        =  0xCD;             // Timer/Counter 2 High
           =1 sfr  PSW          =  0xD0;             // Program Status Word
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 12  

           =1 sfr  REF0CN       =  0xD1;             // Voltage Reference Contro
             -l
           =1 sfr  SCON1        =  0xD2;             // UART1 Control
           =1 sfr  SBUF1        =  0xD3;             // UART1 Data Buffer
           =1 sfr  P0SKIP       =  0xD4;             // Port 0 Skip
           =1 sfr  P1SKIP       =  0xD5;             // Port 1 Skip
           =1 sfr  P2SKIP       =  0xD6;             // Port 2 Skip
           =1 sfr  USB0XCN      =  0xD7;             // USB0 Transceiver Control
           =1 sfr  PCA0CN       =  0xD8;             // PCA0 Control
           =1 sfr  PCA0MD       =  0xD9;             // PCA0 Mode
           =1 sfr  PCA0CPM0     =  0xDA;             // PCA0 Module 0 Mode Regis
             -ter
           =1 sfr  PCA0CPM1     =  0xDB;             // PCA0 Module 1 Mode Regis
             -ter
           =1 sfr  PCA0CPM2     =  0xDC;             // PCA0 Module 2 Mode Regis
             -ter
           =1 sfr  PCA0CPM3     =  0xDD;             // PCA0 Module 3 Mode Regis
             -ter
           =1 sfr  PCA0CPM4     =  0xDE;             // PCA0 Module 4 Mode Regis
             -ter
           =1 sfr  P3SKIP       =  0xDF;             // Port 3 Skip
           =1 sfr  ACC          =  0xE0;             // Accumulator
           =1 sfr  XBR0         =  0xE1;             // Port I/O Crossbar Contro
             -l 0
           =1 sfr  XBR1         =  0xE2;             // Port I/O Crossbar Contro
             -l 1
           =1 sfr  XBR2         =  0xE3;             // Port I/O Crossbar Contro
             -l 2
           =1 sfr  IT01CF       =  0xE4;             // INT0/INT1 Configuration
           =1 sfr  SMOD1        =  0xE5;             // UART1 Mode
           =1 sfr  EIE1         =  0xE6;             // Extended Interrupt Enabl
             -e 1
           =1 sfr  EIE2         =  0xE7;             // Extended Interrupt Enabl
             -e 2
           =1 sfr  ADC0CN       =  0xE8;             // ADC0 Control
           =1 sfr  PCA0CPL1     =  0xE9;             // PCA0 Capture 1 Low
           =1 sfr  PCA0CPH1     =  0xEA;             // PCA0 Capture 1 High
           =1 sfr  PCA0CPL2     =  0xEB;             // PCA0 Capture 2 Low
           =1 sfr  PCA0CPH2     =  0xEC;             // PCA0 Capture 2 High
           =1 sfr  PCA0CPL3     =  0xED;             // PCA0 Capture 3 Low
           =1 sfr  PCA0CPH3     =  0xEE;             // PCA0 Capture 3 High
           =1 sfr  RSTSRC       =  0xEF;             // Reset Source Configurati
             -on/Status
           =1 sfr  B            =  0xF0;             // B Register
           =1 sfr  P0MDIN       =  0xF1;             // Port 0 Input Mode Config
             -uration
           =1 sfr  P1MDIN       =  0xF2;             // Port 1 Input Mode Config
             -uration
           =1 sfr  P2MDIN       =  0xF3;             // Port 2 Input Mode Config
             -uration
           =1 sfr  P3MDIN       =  0xF4;             // Port 3 Input Mode Config
             -uration
           =1 sfr  P4MDIN       =  0xF5;             // Port 4 Input Mode Config
             -uration
           =1 sfr  EIP1         =  0xF6;             // Extended Interrupt Prior
             -ity 1
           =1 sfr  EIP2         =  0xF7;             // Extended Interrupt Prior
             -ity 2
           =1 sfr  SPI0CN       =  0xF8;             // SPI0 Control
           =1 sfr  PCA0L        =  0xF9;             // PCA0 Counter Low
           =1 sfr  PCA0H        =  0xFA;             // PCA0 Counter High
           =1 sfr  PCA0CPL0     =  0xFB;             // PCA0 Capture 0 Low
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 13  

           =1 sfr  PCA0CPH0     =  0xFC;             // PCA0 Capture 0 High
           =1 sfr  PCA0CPL4     =  0xFD;             // PCA0 Capture 4 Low
           =1 sfr  PCA0CPH4     =  0xFE;             // PCA0 Capture 4 High
           =1 sfr  VDM0CN       =  0xFF;             // VDD Monitor Control
           =1 
           =1 
           =1 //----------------------------------------------------------------
             --------------
           =1 // Bit Definitions
           =1 //----------------------------------------------------------------
             --------------
           =1 
           =1 // TCON 0x88
           =1 sbit TF1     = 0x8F;                   // Timer1 overflow flag
           =1 sbit TR1     = 0x8E;                   // Timer1 on/off control
           =1 sbit TF0     = 0x8D;                   // Timer0 overflow flag
           =1 sbit TR0     = 0x8C;                   // Timer0 on/off control
           =1 sbit IE1     = 0x8B;                   // Ext interrupt 1 edge fla
             -g
           =1 sbit IT1     = 0x8A;                   // Ext interrupt 1 type
           =1 sbit IE0     = 0x89;                   // Ext interrupt 0 edge fla
             -g
           =1 sbit IT0     = 0x88;                   // Ext interrupt 0 type
           =1 
           =1 // SCON0 0x98
           =1 sbit S0MODE  = 0x9F;                   // Serial mode control bit 
             -0
           =1                                        // Bit6 UNUSED
           =1 sbit MCE0    = 0x9D;                   // Multiprocessor communica
             -tion enable
           =1 sbit REN0    = 0x9C;                   // Receive enable
           =1 sbit TB80    = 0x9B;                   // Transmit bit 8
           =1 sbit RB80    = 0x9A;                   // Receive bit 8
           =1 sbit TI0     = 0x99;                   // Transmit interrupt flag
           =1 sbit RI0     = 0x98;                   // Receive interrupt flag
           =1 
           =1 // IE 0xA8
           =1 sbit EA      = 0xAF;                   // Global interrupt enable
           =1 sbit ESPI0   = 0xAE;                   // SPI0 interrupt enable
           =1 sbit ET2     = 0xAD;                   // Timer2 interrupt enable
           =1 sbit ES0     = 0xAC;                   // UART0 interrupt enable
           =1 sbit ET1     = 0xAB;                   // Timer1 interrupt enable
           =1 sbit EX1     = 0xAA;                   // External interrupt 1 ena
             -ble
           =1 sbit ET0     = 0xA9;                   // Timer0 interrupt enable
           =1 sbit EX0     = 0xA8;                   // External interrupt 0 ena
             -ble
           =1 
           =1 // IP 0xB8
           =1                                        // Bit7 UNUSED
           =1 sbit PSPI0   = 0xBE;                   // SPI0 interrupt priority
           =1 sbit PT2     = 0xBD;                   // Timer2 priority
           =1 sbit PS0     = 0xBC;                   // UART0 priority
           =1 sbit PT1     = 0xBB;                   // Timer1 priority
           =1 sbit PX1     = 0xBA;                   // External interrupt 1 pri
             -ority
           =1 sbit PT0     = 0xB9;                   // Timer0 priority
           =1 sbit PX0     = 0xB8;                   // External interrupt 0 pri
             -ority
           =1 
           =1 // SMB0CN 0xC0
           =1 sbit MASTER  = 0xC7;                   // Master/slave indicator
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 14  

           =1 sbit TXMODE  = 0xC6;                   // Transmit mode indicator
           =1 sbit STA     = 0xC5;                   // Start flag
           =1 sbit STO     = 0xC4;                   // Stop flag
           =1 sbit ACKRQ   = 0xC3;                   // Acknowledge request
           =1 sbit ARBLOST = 0xC2;                   // Arbitration lost indicat
             -or
           =1 sbit ACK     = 0xC1;                   // Acknowledge flag
           =1 sbit SI      = 0xC0;                   // SMBus interrupt flag
           =1 
           =1 // TMR2CN 0xC8
           =1 sbit TF2H    = 0xCF;                   // Timer2 high byte overflo
             -w flag
           =1 sbit TF2L    = 0xCE;                   // Timer2 low byte overflow
             - flag
           =1 sbit TF2LEN  = 0xCD;                   // Timer2 low byte interrup
             -t enable
           =1 sbit T2CE    = 0xCC;                   // Timer2 capture enable
           =1 sbit T2SPLIT = 0xCB;                   // Timer2 split mode enable
           =1 sbit TR2     = 0xCA;                   // Timer2 on/off control
           =1 sbit T2CSS   = 0xC9;                   // Timer 2 Capture Source s
             -elect
           =1 sbit T2XCLK  = 0xC8;                   // Timer2 external clock se
             -lect
           =1 
           =1 // PSW 0xD0
           =1 sbit CY      = 0xD7;                   // Carry flag
           =1 sbit AC      = 0xD6;                   // Auxiliary carry flag
           =1 sbit F0      = 0xD5;                   // User flag 0
           =1 sbit RS1     = 0xD4;                   // Register bank select 1
           =1 sbit RS0     = 0xD3;                   // Register bank select 0
           =1 sbit OV      = 0xD2;                   // Overflow flag
           =1 sbit F1      = 0xD1;                   // User flag 1
           =1 sbit P       = 0xD0;                   // Accumulator parity flag
           =1 
           =1 // PCA0CN 0xD8
           =1 sbit CF      = 0xDF;                   // PCA0 counter overflow fl
             -ag
           =1 sbit CR      = 0xDE;                   // PCA0 counter run control
           =1                                        // Bit5 UNUSED
           =1 sbit CCF4    = 0xDC;                   // PCA0 module4 capture/com
             -pare flag
           =1 sbit CCF3    = 0xDB;                   // PCA0 module3 capture/com
             -pare flag
           =1 sbit CCF2    = 0xDA;                   // PCA0 module2 capture/com
             -pare flag
           =1 sbit CCF1    = 0xD9;                   // PCA0 module1 capture/com
             -pare flag
           =1 sbit CCF0    = 0xD8;                   // PCA0 module0 capture/com
             -pare flag
           =1 
           =1 // ADC0CN 0xE8
           =1 sbit AD0EN   = 0xEF;                   // ADC0 enable
           =1 sbit AD0TM   = 0xEE;                   // ADC0 track mode
           =1 sbit AD0INT  = 0xED;                   // ADC0 conversion complete
             - interrupt flag
           =1 sbit AD0BUSY = 0xEC;                   // ADC0 busy flag
           =1 sbit AD0WINT = 0xEB;                   // ADC0 window compare inte
             -rrupt flag
           =1 sbit AD0CM2  = 0xEA;                   // ADC0 conversion mode sel
             -ect 2
           =1 sbit AD0CM1  = 0xE9;                   // ADC0 conversion mode sel
             -ect 1
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 15  

           =1 sbit AD0CM0  = 0xE8;                   // ADC0 conversion mode sel
             -ect 0
           =1 
           =1 // SPI0CN 0xF8
           =1 sbit SPIF    = 0xFF;                   // SPI0 interrupt flag
           =1 sbit WCOL    = 0xFE;                   // SPI0 write collision fla
             -g
           =1 sbit MODF    = 0xFD;                   // SPI0 mode fault flag
           =1 sbit RXOVRN  = 0xFC;                   // SPI0 rx overrun flag
           =1 sbit NSSMD1  = 0xFB;                   // SPI0 slave select mode 1
           =1 sbit NSSMD0  = 0xFA;                   // SPI0 slave select mode 0
           =1 sbit TXBMT   = 0xF9;                   // SPI0 transmit buffer emp
             -ty
           =1 sbit SPIEN   = 0xF8;                   // SPI0 SPI enable
           =1 
           =1 
           =1 //----------------------------------------------------------------
             --------------
           =1 // Interrupt Priorities
           =1 //----------------------------------------------------------------
             --------------
           =1 
           =1 #define INTERRUPT_INT0             0   // External Interrupt 0
           =1 #define INTERRUPT_TIMER0           1   // Timer0 Overflow
           =1 #define INTERRUPT_INT1             2   // External Interrupt 1
           =1 #define INTERRUPT_TIMER1           3   // Timer1 Overflow
           =1 #define INTERRUPT_UART0            4   // Serial Port 0
           =1 #define INTERRUPT_TIMER2           5   // Timer2 Overflow
           =1 #define INTERRUPT_SPI0             6   // Serial Peripheral Interf
             -ace 0
           =1 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =1 #define INTERRUPT_USB0             8   // USB Interface
           =1 #define INTERRUPT_ADC0_WINDOW      9   // ADC0 Window Comparison
           =1 #define INTERRUPT_ADC0_EOC         10  // ADC0 End Of Conversion
           =1 #define INTERRUPT_PCA0             11  // PCA0 Peripheral
           =1 #define INTERRUPT_COMPARATOR0      12  // Comparator0
           =1 #define INTERRUPT_COMPARATOR1      13  // Comparator1
           =1 #define INTERRUPT_TIMER3           14  // Timer3 Overflow
           =1 #define INTERRUPT_VBUS_LEVEL       15  // VBUS level-triggered int
             -errupt
           =1 #define INTERRUPT_UART1            16  // Serial Port 1
           =1 
           =1 //----------------------------------------------------------------
             --------------
           =1 // Header File PreProcessor Directive
           =1 //----------------------------------------------------------------
             --------------
           =1 
           =1 #endif                                 // #define C8051F340_H
 289      =1  
 290      =1  //----------------------------------------------------------------
             --------------
 291      =1  // End Of File
 292      =1  //----------------------------------------------------------------
             --------------
  53          #include <stdio.h>
   1      =1  /*----------------------------------------------------------------
             -----------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, In
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 16  

             -c.
   6      =1  All rights reserved.
   7      =1  ------------------------------------------------------------------
             ---------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
  17      =1   #define NULL ((void *) 0)
  18      =1  #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
  54          #include "F34x_MSD_USB_Main.h"                                  // Has SYSCLK #define'd
   1      =1  //----------------------------------------------------------------
             --------------
   2      =1  // F34x_MSD_USB_Main.h
   3      =1  //----------------------------------------------------------------
             --------------
   4      =1  // Copyright 2006 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Main header file for USB firmware. Includes function prototypes
             -,
  10      =1  // standard constants, and configuration constants.//
  11      =1  //
  12      =1  // FID:            34X000063
  13      =1  // Target:         C8051F34x
  14      =1  // Tool chain:     Keil
  15      =1  // Command Line:   See Readme.txt
  16      =1  // Project Name:   F34x_USB_MSD
  17      =1  //
  18      =1  // Release 1.1
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 17  

  19      =1  //    -All changes by PKC
  20      =1  //    -09 JUN 2006
  21      =1  //    -No changes; incremented revision number to match project re
             -vision
  22      =1  //
  23      =1  // Release 1.0
  24      =1  //    -Initial Release
  25      =1  //
  26      =1  // 11/22/02 - DM: 1. Updated function prototypes and added constan
             -ts
  27      =1  //                to F34x_USB_Main.h with sample interrupt firmwar
             -e.
  28      =1  
  29      =1  //----------------------------------------------------------------
             --------------
  30      =1  // Header File Preprocessor Directive
  31      =1  //----------------------------------------------------------------
             --------------
  32      =1  
  33      =1  #ifndef _USB_MAIN_H_
  34      =1  #define _USB_MAIN_H_
  35      =1  
  36      =1  #include "F34x_MSD_Definitions.h"
   1      =2  //----------------------------------------------------------------
             --------------
   2      =2  // F34x_MSD_Definitions.h
   3      =2  //----------------------------------------------------------------
             --------------
   4      =2  // Copyright 2006 Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Header file with all definitions.
  10      =2  //
  11      =2  //
  12      =2  // FID:            34X000032
  13      =2  // Target:         C8051F34x
  14      =2  // Tool chain:     Keil
  15      =2  // Command Line:   See Readme.txt
  16      =2  // Project Name:   F34x_USB_MSD
  17      =2  //
  18      =2  // Release 1.1
  19      =2  //    -All changes by PKC
  20      =2  //    -09 JUN 2006
  21      =2  //    -Replaced SFR definitions file "c8051f320.h" with "c8051f340
             -.h"
  22      =2  //
  23      =2  // Release 1.0
  24      =2  //    -Initial Release
  25      =2  //
  26      =2  
  27      =2  //----------------------------------------------------------------
             --------------
  28      =2  // Header File Preprocessor Directive
  29      =2  //----------------------------------------------------------------
             --------------
  30      =2  
  31      =2  #ifndef __DEFINITIONS_H__
           =2 #define __DEFINITIONS_H__
           =2 
           =2 #define DEBUG_TIMEOUTS
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 18  

           =2 #include "c8051f340.h"
           =2 #ifdef DEBUG_TIMEOUTS
           =2 sbit START_STOP_SPI = P3^0 ;
           =2 sbit START_STOP_READ_TO = P3^1;
           =2 sbit START_STOP_WRITE_TO = P3^2;
           =2 
           =2 #define START_SPI_TIMEOUT (START_STOP_SPI = 1)
           =2 #define STOP_SPI_TIME_OUT (START_STOP_SPI = 0)
           =2 #define START_READ_COPY (START_STOP_READ_TO = 1)
           =2 #define STOP_READ_COPY (START_STOP_READ_TO = 0)
           =2 #define START_WRITE_COPY (START_STOP_WRITE_TO = 1)
           =2 #define STOP_WRITE_COPY (START_STOP_WRITE_TO = 0)
           =2 #else
           =2 
           =2 #define START_SPI_TIMEOUT /\
           =2 /
           =2 #define STOP_SPI_TIME_OUT /\
           =2 /
           =2 #define START_READ_COPY /\
           =2 /
           =2 #define STOP_READ_COPY /\
           =2 /
           =2 #define START_WRITE_COPY /\
           =2 /
           =2 #define STOP_WRITE_COPY /\
           =2 /
           =2 
           =2 #endif
           =2 
           =2 #define ENDLINE         "\r\n"
           =2 #define ENDLINE_SGN '\r'
           =2 
           =2 #endif
  37      =1  //#define _USB_LOW_SPEED_                      // Change this comm
             -ent to make Full/Low speed
  38      =1  
  39      =1  #define SYSCLK                   12000000    // SYSCLK frequency i
             -n Hz
  40      =1  
  41      =1  // USB clock selections (SFR CLKSEL)
  42      =1  #define USB_4X_CLOCK             0x00        // Select 4x clock mu
             -ltiplier, for USB Full Speed
  43      =1  #define USB_INT_OSC_DIV_2        0x10        // See Data Sheet sec
             -tion 13. Oscillators
  44      =1  #define USB_EXT_OSC              0x20
  45      =1  #define USB_EXT_OSC_DIV_2        0x30
  46      =1  #define USB_EXT_OSC_DIV_3        0x40
  47      =1  #define USB_EXT_OSC_DIV_4        0x50
  48      =1  
  49      =1  // System clock selections (SFR CLKSEL)
  50      =1  #define SYS_INT_OSC              0x00        // Select to use inte
             -rnal oscillator
  51      =1  #define SYS_4X_MUL               0x03        // Select to use inte
             -rnal oscillator
  52      =1  #define SYS_EXT_OSC              0x01        // Select to use an e
             -xternal oscillator
  53      =1  #define SYS_4X_DIV_2             0x02
  54      =1  
  55      =1  // BYTE type definition
  56      =1  #ifndef _BYTE_DEF_
  57      =1  #define _BYTE_DEF_
  58      =1  typedef unsigned char BYTE;
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 19  

  59      =1  #endif   /* _BYTE_DEF_ */
  60      =1  
  61      =1  // WORD type definition, for KEIL Compiler
  62      =1  #ifndef _WORD_DEF_                           // Compiler Specific,
             - written for Little Endian
  63      =1  #define _WORD_DEF_
  64      =1  typedef union {unsigned int i; unsigned char c[2];} WORD;
  65      =1  #define LSB 1                                // All words sent to 
             -and received from the host are
  66      =1  #define MSB 0                                // little endian, thi
             -s is switched by software when
  67      =1                                               // neccessary.  These
             - sections of code have been marked
  68      =1                                                                                           // with "Compiler Specific" as above for easier modifi
             -cation
  69      =1  #endif   /* _WORD_DEF_ */
  70      =1  
  71      =1  // DWORD type definition
  72      =1  #ifndef _DWORD_DEF_
  73      =1  #define _DWORD_DEF_
  74      =1  typedef unsigned long DWORD;
  75      =1  #endif /* _DWORD_DEF_ */
  76      =1  
  77      =1  extern volatile DWORD xdata tickcount;
  78      =1  
  79      =1  // Define Endpoint Packet Sizes
  80      =1  #ifdef _USB_LOW_SPEED_
           =1 #define  EP0_PACKET_SIZE         0x40        // This value can be 
             -8,16,32,64 depending on device speed, see USB spec
           =1 #else
  83      =1  #define  EP0_PACKET_SIZE         0x40
  84      =1  #endif /* _USB_LOW_SPEED_ */ 
  85      =1  
  86      =1  #define  EP1_PACKET_SIZE         0x0040      // Can range 0 - 1024
             - depending on data and transfer type  
  87      =1  #define  EP1_PACKET_SIZE_LE      0x4000      // IMPORTANT- this sh
             -ould be Little-Endian version of EP1_PACKET_SIZE
  88      =1  #define  EP2_PACKET_SIZE         0x0040      // Can range 0 - 1024
             - depending on data and transfer type
  89      =1  #define  EP2_PACKET_SIZE_LE      0x4000      // IMPORTANT- this sh
             -ould be Little-Endian version of EP2_PACKET_SIZE
  90      =1  
  91      =1  // Standard Descriptor Types
  92      =1  #define  DSC_DEVICE              0x01        // Device Descriptor
  93      =1  #define  DSC_CONFIG              0x02        // Configuration Desc
             -riptor
  94      =1  #define  DSC_STRING              0x03        // String Descriptor
  95      =1  #define  DSC_INTERFACE           0x04        // Interface Descript
             -or
  96      =1  #define  DSC_ENDPOINT            0x05        // Endpoint Descripto
             -r
  97      =1  
  98      =1  // HID Descriptor Types
  99      =1  #define DSC_HID                                 0x21            // HID Class Descriptor
 100      =1  #define DSC_HID_REPORT                  0x22            // HID Report Descriptor
 101      =1  
 102      =1  // Standard Request Codes
 103      =1  #define  GET_STATUS             0x00        // Code for Get Status
 104      =1  #define  CLEAR_FEATURE          0x01        // Code for Clear Feat
             -ure
 105      =1  #define  SET_FEATURE            0x03        // Code for Set Featur
             -e
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 20  

 106      =1  #define  SET_ADDRESS            0x05        // Code for Set Addres
             -s
 107      =1  #define  GET_DESCRIPTOR         0x06        // Code for Get Descri
             -ptor
 108      =1  #define  SET_DESCRIPTOR         0x07        // Code for Set Descri
             -ptor(not used)
 109      =1  #define  GET_CONFIGURATION      0x08        // Code for Get Config
             -uration
 110      =1  #define  SET_CONFIGURATION      0x09        // Code for Set Config
             -uration
 111      =1  #define  GET_INTERFACE          0x0A        // Code for Get Interf
             -ace
 112      =1  #define  SET_INTERFACE          0x0B        // Code for Set Interf
             -ace
 113      =1  #define  SYNCH_FRAME            0x0C        // Code for Synch Fram
             -e(not used)
 114      =1  #define  MSD_RESET                              0xFF            // Mass-storage device Reset
 115      =1  #define  MSD_GET_MAX_LUN                0xFE            // Mass-storage device Get Max LU
             -N
 116      =1  
 117      =1  // HID Request Codes
 118      =1  #define GET_REPORT                              0x01            // Code for Get Report
 119      =1  #define GET_IDLE                                0x02            // Code for Get Idle
 120      =1  #define GET_PROTOCOL                    0x03            // Code for Get Protocol
 121      =1  #define SET_REPORT                              0x09            // Code for Set Report
 122      =1  #define SET_IDLE                                0x0A            // Code for Set Idle
 123      =1  #define SET_PROTOCOL                    0x0B            // Code for Set Protocol
 124      =1  
 125      =1  // Define device states
 126      =1  #define  DEV_ATTACHED            0x00        // Device is in Attac
             -hed State
 127      =1  #define  DEV_POWERED             0x01        // Device is in Power
             -ed State
 128      =1  #define  DEV_DEFAULT             0x02        // Device is in Defau
             -lt State
 129      =1  #define  DEV_ADDRESS             0x03        // Device is in Addre
             -ssed State
 130      =1  #define  DEV_CONFIGURED          0x04        // Device is in Confi
             -gured State
 131      =1  #define  DEV_SUSPENDED           0x05        // Device is in Suspe
             -nded State
 132      =1  
 133      =1  // Define bmRequestType bitmaps
 134      =1  #define  IN_DEVICE               0x00        // Request made to de
             -vice, direction is IN 
 135      =1  #define  OUT_DEVICE              0x80        // Request made to de
             -vice, direction is OUT
 136      =1  #define  IN_INTERFACE            0x01        // Request made to in
             -terface, direction is IN
 137      =1  #define  OUT_INTERFACE           0x81        // Request made to in
             -terface, direction is OUT
 138      =1  #define  IN_ENDPOINT             0x02        // Request made to en
             -dpoint, direction is IN
 139      =1  #define  OUT_ENDPOINT            0x82        // Request made to en
             -dpoint, direction is OUT
 140      =1  
 141      =1  // Define wIndex bitmaps
 142      =1  #define  IN_EP1                  0x81        // Index values used 
             -by Set and Clear feature
 143      =1  #define  OUT_EP1                 0x01        // commands for Endpo
             -int_Halt
 144      =1  #define  IN_EP2                  0x82
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 21  

 145      =1  #ifdef __F326_VER__
           =1 #define  OUT_EP2                                 0x01           
           =1 #else
 148      =1  #define  OUT_EP2                                 0x01           
 149      =1  #endif
 150      =1  
 151      =1  // Define wValue bitmaps for Standard Feature Selectors
 152      =1  #define  DEVICE_REMOTE_WAKEUP    0x01        // Remote wakeup feat
             -ure(not used)
 153      =1  #define  ENDPOINT_HALT           0x00        // Endpoint_Halt feat
             -ure selector
 154      =1  
 155      =1  // Define Endpoint States
 156      =1  #define  EP_IDLE                 0x00        // This signifies End
             -point Idle State
 157      =1  #define  EP_TX                   0x01        // Endpoint Transmit 
             -State
 158      =1  #define  EP_RX                   0x02        // Endpoint Receive S
             -tate
 159      =1  #define  EP_HALT                 0x03        // Endpoint Halt Stat
             -e (return stalls)
 160      =1  #define  EP_STALL                0x04        // Endpoint Stall (se
             -nd procedural stall next status phase)
 161      =1  #define  EP_ADDRESS              0x05        // Endpoint Address (
             -change FADDR during next status phase)
 162      =1  
 163      =1  // Function prototypes
 164      =1  // USB Routines
 165      =1  void USB_Resume(void);                       // This routine resum
             -es USB operation
 166      =1  void USB_Reset(void);                        // Called after USB b
             -us reset
 167      =1  void Handle_Setup(void);                     // Handle setup packe
             -t on Endpoint 0
 168      =1  void Handle_In1(BYTE* ptr_buf);                       // Handle in
             - packet on Endpoint 1
 169      =1  void Handle_Out2(void);                      // Handle out packet 
             -on Endpoint 2
 170      =1  void USB_Suspend(void);                      // This routine calle
             -d when suspend signalling on bus
 171      =1  void Out2_Get_Data(BYTE* ptr_buf);                               // Copies from FIFO to ptr_
             -buf, clears FIFO-full flag.
 172      =1  void Out2_Done(void);                                            // Call this when finished with the d
             -ata
 173      =1  
 174      =1  // Standard Requests
 175      =1  void Get_Status(void);                       // These are called f
             -or each specific standard request
 176      =1  void Clear_Feature(void);
 177      =1  void Set_Feature(void);
 178      =1  void Set_Address(void);
 179      =1  void Get_Descriptor(void);
 180      =1  void Get_Configuration(void);
 181      =1  void Set_Configuration(void);
 182      =1  void Get_Interface(void);
 183      =1  void Set_Interface(void);
 184      =1  
 185      =1  // MSD Specific Requests
 186      =1  // void Reset_Msd(void);
 187      =1  // void Get_MaxLUN(void);
 188      =1  
 189      =1  // Initialization Routines
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 22  

 190      =1  void Sys_Clk_Init(void);                      // Initialize the sy
             -stem clock(depends on Full/Low speed)
 191      =1  void Port_Init(void);                        // Configure ports fo
             -r this specific application
 192      =1  void USB0_Init(void);                        // Configure USB core
             - for either Full/Low speed
 193      =1  void Timer_Init(void);                       // Start timer 2 for 
             -use by ADC and to check switches
 194      =1  void Adc_Init(void);                         // Configure ADC for 
             -continuous conversion, low-power mode
 195      =1  
 196      =1  // Other Routines
 197      =1  void Timer2_ISR(void);                       // Called when Timer 
             -2 overflows, see if switches are pressed
 198      =1  void Adc_ConvComple_ISR(void);               // When a conversion 
             -completes, switch ADC multiplexor
 199      =1  void USB_ISR(void);                          // Called to determin
             -e type of USB interrupt
 200      =1  void Fifo_ReadC(BYTE, unsigned int, BYTE *) ;
 201      =1  extern void Fifo_Read (BYTE, unsigned int, BYTE *) ; // Used for m
             -ultiple byte reads of Endpoint fifos
 202      =1  extern void Fifo_Write (BYTE, unsigned int, BYTE *) reentrant;// U
             -sed for multiple byte writes of Endpoint fifos
 203      =1  void Force_Stall(void);                      // Forces a procedura
             -l stall on Endpoint 0
 204      =1  void Delay(void);                            // Approximately 80 u
             -s/1 ms on Full/Low Speed
 205      =1  
 206      =1  void USB_In(BYTE* ptr_buf,unsigned count);
 207      =1  
 208      =1  void USB_Bulk_Init(void);
 209      =1  
 210      =1  extern unsigned xdata Out_Count;
 211      =1  extern BYTE xdata Out_Packet[EP2_PACKET_SIZE];
 212      =1  extern BYTE xdata In_count;
 213      =1  extern BYTE xdata In_Packet[EP1_PACKET_SIZE];
 214      =1  //extern BYTE xdata In_Overrun;
 215      =1  
 216      =1  #endif      /* _USB_MAIN_H_ */
 217      =1  
  55          #include "F34x_MSD_Physical_Settings.h"
   1      =1  //----------------------------------------------------------------
             --------------
   2      =1  // F34x_MSD_Physical_Settings.h
   3      =1  //----------------------------------------------------------------
             --------------
   4      =1  // Copyright 2006 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Header file with common definitions
  10      =1  //
  11      =1  //
  12      =1  // FID:            34X000048
  13      =1  // Target:         C8051F34x
  14      =1  // Tool chain:     Keil
  15      =1  // Command Line:   See Readme.txt
  16      =1  // Project Name:   F34x_USB_MSD
  17      =1  //
  18      =1  // Release 1.1
  19      =1  //    -All changes by PKC
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 23  

  20      =1  //    -09 JUN 2006
  21      =1  //    -Replaced SFR definitions file "c8051f320.h" with "c8051f340
             -.h"
  22      =1  //
  23      =1  // Release 1.0
  24      =1  //    -Initial Release
  25      =1  //
  26      =1  
  27      =1  //----------------------------------------------------------------
             --------------
  28      =1  // Header File Preprocessor Directive
  29      =1  //----------------------------------------------------------------
             --------------
  30      =1  
  31      =1  #ifndef __PHYSICAL_SETTINGS_H__
  32      =1  #define __PHYSICAL_SETTINGS_H__
  33      =1  
  34      =1  #include "c8051f340.h"
   1      =2  //----------------------------------------------------------------
             --------------
   2      =2  // C8051F340.h
   3      =2  //----------------------------------------------------------------
             --------------
   4      =2  // Copyright 2005 Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F34x family.
  10      =2  //
  11      =2  //
  12      =2  // FID:            34X000002
  13      =2  // Target:         C8051F340, 'F341, 'F342, 'F343, 'F344, 'F345, '
             -F346, 'F347
  14      =2  // Tool chain:     Keil
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 1.0
  18      =2  //    -Initial Release (GP\PKC)
  19      =2  //    -13 DEC 2005
  20      =2  
  21      =2  //----------------------------------------------------------------
             --------------
  22      =2  // Header File Preprocessor Directive
  23      =2  //----------------------------------------------------------------
             --------------
  24      =2  
  25      =2  #ifndef C8051F340_H
           =2 #define C8051F340_H
           =2 
           =2 //----------------------------------------------------------------
             --------------
           =2 // Byte Registers
           =2 //----------------------------------------------------------------
             --------------
           =2 
           =2 sfr  P0           =  0x80;             // Port 0 Latch
           =2 sfr  SP           =  0x81;             // Stack Pointer
           =2 sfr  DPL          =  0x82;             // Data Pointer Low
           =2 sfr  DPH          =  0x83;             // Data Pointer High
           =2 sfr  EMI0TC       =  0x84;             // EMIF Timing
           =2 sfr  EMI0CF       =  0x85;             // EMIF Configuration
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 24  

           =2 sfr  OSCLCN       =  0x86;             // Internal Low-Freq Oscill
             -ator Control
           =2 sfr  PCON         =  0x87;             // Power Control
           =2 sfr  TCON         =  0x88;             // Timer/Counter Control
           =2 sfr  TMOD         =  0x89;             // Timer/Counter Mode
           =2 sfr  TL0          =  0x8A;             // Timer/Counter 0 Low
           =2 sfr  TL1          =  0x8B;             // Timer/Counter 1 Low
           =2 sfr  TH0          =  0x8C;             // Timer/Counter 0 High
           =2 sfr  TH1          =  0x8D;             // Timer/Counter 1 High
           =2 sfr  CKCON        =  0x8E;             // Clock Control
           =2 sfr  PSCTL        =  0x8F;             // Program Store R/W Contro
             -l
           =2 sfr  P1           =  0x90;             // Port 1 Latch
           =2 sfr  TMR3CN       =  0x91;             // Timer/Counter 3Control
           =2 sfr  TMR3RLL      =  0x92;             // Timer/Counter 3 Reload L
             -ow
           =2 sfr  TMR3RLH      =  0x93;             // Timer/Counter 3 Reload H
             -igh
           =2 sfr  TMR3L        =  0x94;             // Timer/Counter 3Low
           =2 sfr  TMR3H        =  0x95;             // Timer/Counter 3 High
           =2 sfr  USB0ADR      =  0x96;             // USB0 Indirect Address Re
             -gister
           =2 sfr  USB0DAT      =  0x97;             // USB0 Data Register
           =2 sfr  SCON0        =  0x98;             // UART0 Control
           =2 sfr  SBUF0        =  0x99;             // UART0 Data Buffer
           =2 sfr  CPT1CN       =  0x9A;             // Comparator1 Control
           =2 sfr  CPT0CN       =  0x9B;             // Comparator0 Control
           =2 sfr  CPT1MD       =  0x9C;             // Comparator1 Mode Selecti
             -on
           =2 sfr  CPT0MD       =  0x9D;             // Comparator0 Mode Selecti
             -on
           =2 sfr  CPT1MX       =  0x9E;             // Comparator1 MUX Selectio
             -n
           =2 sfr  CPT0MX       =  0x9F;             // Comparator0 MUX Selectio
             -n
           =2 sfr  P2           =  0xA0;             // Port 2 Latch
           =2 sfr  SPI0CFG      =  0xA1;             // SPI Configuration
           =2 sfr  SPI0CKR      =  0xA2;             // SPI Clock Rate Control
           =2 sfr  SPI0DAT      =  0xA3;             // SPI Data
           =2 sfr  P0MDOUT      =  0xA4;             // Port 0 Output Mode Confi
             -guration
           =2 sfr  P1MDOUT      =  0xA5;             // Port 1 Output Mode Confi
             -guration
           =2 sfr  P2MDOUT      =  0xA6;             // Port 2 Output Mode Confi
             -guration
           =2 sfr  P3MDOUT      =  0xA7;             // Port 3 Output Mode Confi
             -guration
           =2 sfr  IE           =  0xA8;             // Interrupt Enable
           =2 sfr  CLKSEL       =  0xA9;             // Clock Select
           =2 sfr  EMI0CN       =  0xAA;             // External Memory Interfac
             -e Control
           =2 sfr  SBCON1       =  0xAC;             // UART1 Baud Rate Generato
             -r Control
           =2 sfr  P4MDOUT      =  0xAE;             // Port 4 Output Mode Confi
             -guration
           =2 sfr  PFE0CN       =  0xAF;             // Prefetch Engine Control
           =2 sfr  P3           =  0xB0;             // Port 3 Latch
           =2 sfr  OSCXCN       =  0xB1;             // External Oscillator Cont
             -rol
           =2 sfr  OSCICN       =  0xB2;             // Internal Oscillator Cont
             -rol
           =2 sfr  OSCICL       =  0xB3;             // Internal Oscillator Cali
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 25  

             -bration
           =2 sfr  SBRLL1       =  0xB4;             // UART1 Baud Rate Generato
             -r Low
           =2 sfr  SBRLH1       =  0xB5;             // UART1 Baud Rate Generato
             -r High
           =2 sfr  FLSCL        =  0xB6;             // Flash Scale
           =2 sfr  FLKEY        =  0xB7;             // Flash Lock and Key
           =2 sfr  IP           =  0xB8;             // Interrupt Priority
           =2 sfr  CLKMUL       =  0xB9;             // Clock Multiplier
           =2 sfr  AMX0N        =  0xBA;             // AMUX0 Negative Channel S
             -elect
           =2 sfr  AMX0P        =  0xBB;             // AMUX0 Positive Channel S
             -elect
           =2 sfr  ADC0CF       =  0xBC;             // ADC0 Configuration
           =2 sfr  ADC0L        =  0xBD;             // ADC0 Low
           =2 sfr  ADC0H        =  0xBE;             // ADC0 High
           =2 sfr  SMB0CN       =  0xC0;             // SMBus Control
           =2 sfr  SMB0CF       =  0xC1;             // SMBus Configuration
           =2 sfr  SMB0DAT      =  0xC2;             // SMBus Data
           =2 sfr  ADC0GTL      =  0xC3;             // ADC0 Greater-Than Compar
             -e Low
           =2 sfr  ADC0GTH      =  0xC4;             // ADC0 Greater-Than Compar
             -e High
           =2 sfr  ADC0LTL      =  0xC5;             // ADC0 Less-Than Compare W
             -ord Low
           =2 sfr  ADC0LTH      =  0xC6;             // ADC0 Less-Than Compare W
             -ord High
           =2 sfr  P4           =  0xC7;             // Port 4 Latch
           =2 sfr  TMR2CN       =  0xC8;             // Timer/Counter 2 Control
           =2 sfr  REG0CN       =  0xC9;             // Voltage Regulator Contro
             -l
           =2 sfr  TMR2RLL      =  0xCA;             // Timer/Counter 2 Reload L
             -ow
           =2 sfr  TMR2RLH      =  0xCB;             // Timer/Counter 2 Reload H
             -igh
           =2 sfr  TMR2L        =  0xCC;             // Timer/Counter 2 Low
           =2 sfr  TMR2H        =  0xCD;             // Timer/Counter 2 High
           =2 sfr  PSW          =  0xD0;             // Program Status Word
           =2 sfr  REF0CN       =  0xD1;             // Voltage Reference Contro
             -l
           =2 sfr  SCON1        =  0xD2;             // UART1 Control
           =2 sfr  SBUF1        =  0xD3;             // UART1 Data Buffer
           =2 sfr  P0SKIP       =  0xD4;             // Port 0 Skip
           =2 sfr  P1SKIP       =  0xD5;             // Port 1 Skip
           =2 sfr  P2SKIP       =  0xD6;             // Port 2 Skip
           =2 sfr  USB0XCN      =  0xD7;             // USB0 Transceiver Control
           =2 sfr  PCA0CN       =  0xD8;             // PCA0 Control
           =2 sfr  PCA0MD       =  0xD9;             // PCA0 Mode
           =2 sfr  PCA0CPM0     =  0xDA;             // PCA0 Module 0 Mode Regis
             -ter
           =2 sfr  PCA0CPM1     =  0xDB;             // PCA0 Module 1 Mode Regis
             -ter
           =2 sfr  PCA0CPM2     =  0xDC;             // PCA0 Module 2 Mode Regis
             -ter
           =2 sfr  PCA0CPM3     =  0xDD;             // PCA0 Module 3 Mode Regis
             -ter
           =2 sfr  PCA0CPM4     =  0xDE;             // PCA0 Module 4 Mode Regis
             -ter
           =2 sfr  P3SKIP       =  0xDF;             // Port 3 Skip
           =2 sfr  ACC          =  0xE0;             // Accumulator
           =2 sfr  XBR0         =  0xE1;             // Port I/O Crossbar Contro
             -l 0
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 26  

           =2 sfr  XBR1         =  0xE2;             // Port I/O Crossbar Contro
             -l 1
           =2 sfr  XBR2         =  0xE3;             // Port I/O Crossbar Contro
             -l 2
           =2 sfr  IT01CF       =  0xE4;             // INT0/INT1 Configuration
           =2 sfr  SMOD1        =  0xE5;             // UART1 Mode
           =2 sfr  EIE1         =  0xE6;             // Extended Interrupt Enabl
             -e 1
           =2 sfr  EIE2         =  0xE7;             // Extended Interrupt Enabl
             -e 2
           =2 sfr  ADC0CN       =  0xE8;             // ADC0 Control
           =2 sfr  PCA0CPL1     =  0xE9;             // PCA0 Capture 1 Low
           =2 sfr  PCA0CPH1     =  0xEA;             // PCA0 Capture 1 High
           =2 sfr  PCA0CPL2     =  0xEB;             // PCA0 Capture 2 Low
           =2 sfr  PCA0CPH2     =  0xEC;             // PCA0 Capture 2 High
           =2 sfr  PCA0CPL3     =  0xED;             // PCA0 Capture 3 Low
           =2 sfr  PCA0CPH3     =  0xEE;             // PCA0 Capture 3 High
           =2 sfr  RSTSRC       =  0xEF;             // Reset Source Configurati
             -on/Status
           =2 sfr  B            =  0xF0;             // B Register
           =2 sfr  P0MDIN       =  0xF1;             // Port 0 Input Mode Config
             -uration
           =2 sfr  P1MDIN       =  0xF2;             // Port 1 Input Mode Config
             -uration
           =2 sfr  P2MDIN       =  0xF3;             // Port 2 Input Mode Config
             -uration
           =2 sfr  P3MDIN       =  0xF4;             // Port 3 Input Mode Config
             -uration
           =2 sfr  P4MDIN       =  0xF5;             // Port 4 Input Mode Config
             -uration
           =2 sfr  EIP1         =  0xF6;             // Extended Interrupt Prior
             -ity 1
           =2 sfr  EIP2         =  0xF7;             // Extended Interrupt Prior
             -ity 2
           =2 sfr  SPI0CN       =  0xF8;             // SPI0 Control
           =2 sfr  PCA0L        =  0xF9;             // PCA0 Counter Low
           =2 sfr  PCA0H        =  0xFA;             // PCA0 Counter High
           =2 sfr  PCA0CPL0     =  0xFB;             // PCA0 Capture 0 Low
           =2 sfr  PCA0CPH0     =  0xFC;             // PCA0 Capture 0 High
           =2 sfr  PCA0CPL4     =  0xFD;             // PCA0 Capture 4 Low
           =2 sfr  PCA0CPH4     =  0xFE;             // PCA0 Capture 4 High
           =2 sfr  VDM0CN       =  0xFF;             // VDD Monitor Control
           =2 
           =2 
           =2 //----------------------------------------------------------------
             --------------
           =2 // Bit Definitions
           =2 //----------------------------------------------------------------
             --------------
           =2 
           =2 // TCON 0x88
           =2 sbit TF1     = 0x8F;                   // Timer1 overflow flag
           =2 sbit TR1     = 0x8E;                   // Timer1 on/off control
           =2 sbit TF0     = 0x8D;                   // Timer0 overflow flag
           =2 sbit TR0     = 0x8C;                   // Timer0 on/off control
           =2 sbit IE1     = 0x8B;                   // Ext interrupt 1 edge fla
             -g
           =2 sbit IT1     = 0x8A;                   // Ext interrupt 1 type
           =2 sbit IE0     = 0x89;                   // Ext interrupt 0 edge fla
             -g
           =2 sbit IT0     = 0x88;                   // Ext interrupt 0 type
           =2 
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 27  

           =2 // SCON0 0x98
           =2 sbit S0MODE  = 0x9F;                   // Serial mode control bit 
             -0
           =2                                        // Bit6 UNUSED
           =2 sbit MCE0    = 0x9D;                   // Multiprocessor communica
             -tion enable
           =2 sbit REN0    = 0x9C;                   // Receive enable
           =2 sbit TB80    = 0x9B;                   // Transmit bit 8
           =2 sbit RB80    = 0x9A;                   // Receive bit 8
           =2 sbit TI0     = 0x99;                   // Transmit interrupt flag
           =2 sbit RI0     = 0x98;                   // Receive interrupt flag
           =2 
           =2 // IE 0xA8
           =2 sbit EA      = 0xAF;                   // Global interrupt enable
           =2 sbit ESPI0   = 0xAE;                   // SPI0 interrupt enable
           =2 sbit ET2     = 0xAD;                   // Timer2 interrupt enable
           =2 sbit ES0     = 0xAC;                   // UART0 interrupt enable
           =2 sbit ET1     = 0xAB;                   // Timer1 interrupt enable
           =2 sbit EX1     = 0xAA;                   // External interrupt 1 ena
             -ble
           =2 sbit ET0     = 0xA9;                   // Timer0 interrupt enable
           =2 sbit EX0     = 0xA8;                   // External interrupt 0 ena
             -ble
           =2 
           =2 // IP 0xB8
           =2                                        // Bit7 UNUSED
           =2 sbit PSPI0   = 0xBE;                   // SPI0 interrupt priority
           =2 sbit PT2     = 0xBD;                   // Timer2 priority
           =2 sbit PS0     = 0xBC;                   // UART0 priority
           =2 sbit PT1     = 0xBB;                   // Timer1 priority
           =2 sbit PX1     = 0xBA;                   // External interrupt 1 pri
             -ority
           =2 sbit PT0     = 0xB9;                   // Timer0 priority
           =2 sbit PX0     = 0xB8;                   // External interrupt 0 pri
             -ority
           =2 
           =2 // SMB0CN 0xC0
           =2 sbit MASTER  = 0xC7;                   // Master/slave indicator
           =2 sbit TXMODE  = 0xC6;                   // Transmit mode indicator
           =2 sbit STA     = 0xC5;                   // Start flag
           =2 sbit STO     = 0xC4;                   // Stop flag
           =2 sbit ACKRQ   = 0xC3;                   // Acknowledge request
           =2 sbit ARBLOST = 0xC2;                   // Arbitration lost indicat
             -or
           =2 sbit ACK     = 0xC1;                   // Acknowledge flag
           =2 sbit SI      = 0xC0;                   // SMBus interrupt flag
           =2 
           =2 // TMR2CN 0xC8
           =2 sbit TF2H    = 0xCF;                   // Timer2 high byte overflo
             -w flag
           =2 sbit TF2L    = 0xCE;                   // Timer2 low byte overflow
             - flag
           =2 sbit TF2LEN  = 0xCD;                   // Timer2 low byte interrup
             -t enable
           =2 sbit T2CE    = 0xCC;                   // Timer2 capture enable
           =2 sbit T2SPLIT = 0xCB;                   // Timer2 split mode enable
           =2 sbit TR2     = 0xCA;                   // Timer2 on/off control
           =2 sbit T2CSS   = 0xC9;                   // Timer 2 Capture Source s
             -elect
           =2 sbit T2XCLK  = 0xC8;                   // Timer2 external clock se
             -lect
           =2 
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 28  

           =2 // PSW 0xD0
           =2 sbit CY      = 0xD7;                   // Carry flag
           =2 sbit AC      = 0xD6;                   // Auxiliary carry flag
           =2 sbit F0      = 0xD5;                   // User flag 0
           =2 sbit RS1     = 0xD4;                   // Register bank select 1
           =2 sbit RS0     = 0xD3;                   // Register bank select 0
           =2 sbit OV      = 0xD2;                   // Overflow flag
           =2 sbit F1      = 0xD1;                   // User flag 1
           =2 sbit P       = 0xD0;                   // Accumulator parity flag
           =2 
           =2 // PCA0CN 0xD8
           =2 sbit CF      = 0xDF;                   // PCA0 counter overflow fl
             -ag
           =2 sbit CR      = 0xDE;                   // PCA0 counter run control
           =2                                        // Bit5 UNUSED
           =2 sbit CCF4    = 0xDC;                   // PCA0 module4 capture/com
             -pare flag
           =2 sbit CCF3    = 0xDB;                   // PCA0 module3 capture/com
             -pare flag
           =2 sbit CCF2    = 0xDA;                   // PCA0 module2 capture/com
             -pare flag
           =2 sbit CCF1    = 0xD9;                   // PCA0 module1 capture/com
             -pare flag
           =2 sbit CCF0    = 0xD8;                   // PCA0 module0 capture/com
             -pare flag
           =2 
           =2 // ADC0CN 0xE8
           =2 sbit AD0EN   = 0xEF;                   // ADC0 enable
           =2 sbit AD0TM   = 0xEE;                   // ADC0 track mode
           =2 sbit AD0INT  = 0xED;                   // ADC0 conversion complete
             - interrupt flag
           =2 sbit AD0BUSY = 0xEC;                   // ADC0 busy flag
           =2 sbit AD0WINT = 0xEB;                   // ADC0 window compare inte
             -rrupt flag
           =2 sbit AD0CM2  = 0xEA;                   // ADC0 conversion mode sel
             -ect 2
           =2 sbit AD0CM1  = 0xE9;                   // ADC0 conversion mode sel
             -ect 1
           =2 sbit AD0CM0  = 0xE8;                   // ADC0 conversion mode sel
             -ect 0
           =2 
           =2 // SPI0CN 0xF8
           =2 sbit SPIF    = 0xFF;                   // SPI0 interrupt flag
           =2 sbit WCOL    = 0xFE;                   // SPI0 write collision fla
             -g
           =2 sbit MODF    = 0xFD;                   // SPI0 mode fault flag
           =2 sbit RXOVRN  = 0xFC;                   // SPI0 rx overrun flag
           =2 sbit NSSMD1  = 0xFB;                   // SPI0 slave select mode 1
           =2 sbit NSSMD0  = 0xFA;                   // SPI0 slave select mode 0
           =2 sbit TXBMT   = 0xF9;                   // SPI0 transmit buffer emp
             -ty
           =2 sbit SPIEN   = 0xF8;                   // SPI0 SPI enable
           =2 
           =2 
           =2 //----------------------------------------------------------------
             --------------
           =2 // Interrupt Priorities
           =2 //----------------------------------------------------------------
             --------------
           =2 
           =2 #define INTERRUPT_INT0             0   // External Interrupt 0
           =2 #define INTERRUPT_TIMER0           1   // Timer0 Overflow
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 29  

           =2 #define INTERRUPT_INT1             2   // External Interrupt 1
           =2 #define INTERRUPT_TIMER1           3   // Timer1 Overflow
           =2 #define INTERRUPT_UART0            4   // Serial Port 0
           =2 #define INTERRUPT_TIMER2           5   // Timer2 Overflow
           =2 #define INTERRUPT_SPI0             6   // Serial Peripheral Interf
             -ace 0
           =2 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =2 #define INTERRUPT_USB0             8   // USB Interface
           =2 #define INTERRUPT_ADC0_WINDOW      9   // ADC0 Window Comparison
           =2 #define INTERRUPT_ADC0_EOC         10  // ADC0 End Of Conversion
           =2 #define INTERRUPT_PCA0             11  // PCA0 Peripheral
           =2 #define INTERRUPT_COMPARATOR0      12  // Comparator0
           =2 #define INTERRUPT_COMPARATOR1      13  // Comparator1
           =2 #define INTERRUPT_TIMER3           14  // Timer3 Overflow
           =2 #define INTERRUPT_VBUS_LEVEL       15  // VBUS level-triggered int
             -errupt
           =2 #define INTERRUPT_UART1            16  // Serial Port 1
           =2 
           =2 //----------------------------------------------------------------
             --------------
           =2 // Header File PreProcessor Directive
           =2 //----------------------------------------------------------------
             --------------
           =2 
           =2 #endif                                 // #define C8051F340_H
 289      =2  
 290      =2  //----------------------------------------------------------------
             --------------
 291      =2  // End Of File
 292      =2  //----------------------------------------------------------------
             --------------
  35      =1  
  36      =1  // Physical size in bytes of one MMC FLASH sector
  37      =1  #define PHYSICAL_BLOCK_SIZE     512   
  38      =1  
  39      =1  sbit SCLK = P0^0;
  40      =1  sbit SCS  = P0^3;
  41      =1  sbit MISO = P0^1;
  42      =1  sbit MOSI = P0^2;
  43      =1  
  44      =1  #endif
  56          #include "F34x_MSD_MMC.h"
   1      =1  //----------------------------------------------------------------
             --------------
   2      =1  // F34x_MSD_MMC.h
   3      =1  //----------------------------------------------------------------
             --------------
   4      =1  // Copyright 2006 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Header file with function prototypes relevant to F34x_MMC.c
  10      =1  //
  11      =1  //
  12      =1  // FID:            34X000044
  13      =1  // Target:         C8051F34x
  14      =1  // Tool chain:     Keil
  15      =1  // Command Line:   See Readme.txt
  16      =1  // Project Name:   F34x_USB_MSD
  17      =1  //
  18      =1  // Release 1.1
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 30  

  19      =1  //    -All changes by PKC
  20      =1  //    -09 JUN 2006
  21      =1  //    -No changes; incremented revision number to match project re
             -vision
  22      =1  //
  23      =1  // Release 1.0
  24      =1  //    -Initial Release
  25      =1  //
  26      =1  
  27      =1  //----------------------------------------------------------------
             --------------
  28      =1  // Header File Preprocessor Directive
  29      =1  //----------------------------------------------------------------
             --------------
  30      =1  
  31      =1  #ifndef _MMC_H_
  32      =1  #define _MMC_H_
  33      =1  
  34      =1  // MMC_FLASH Functions
  35      =1  
  36      =1  
  37      =1  
  38      =1  void MMC_FLASH_Init (void);            // Initializes MMC and conf
             -igures it to 
  39      =1                                         // accept SPI commands;
  40      =1  
  41      =1  unsigned int MMC_FLASH_Block_Read(unsigned long address, unsigned 
             -char *pchar);
  42      =1  unsigned char MMC_FLASH_Block_Write(unsigned long address,unsigned
             - char *wdata);
  43      =1  
  44      =1  #ifdef __F340_VER__
  45      =1  void Get_Status_MMC();
  46      =1  #endif
  47      =1  
  48      =1  #endif
  57          #include <intrins.h>
   1      =1  /*----------------------------------------------------------------
             -----------
   2      =1  INTRINS.H
   3      =1  
   4      =1  Intrinsic functions for C51.
   5      =1  Copyright (c) 1988-2004 Keil Elektronik GmbH and Keil Software, In
             -c.
   6      =1  All rights reserved.
   7      =1  ------------------------------------------------------------------
             ---------*/
   8      =1  
   9      =1  #ifndef __INTRINS_H__
  10      =1  #define __INTRINS_H__
  11      =1  
  12      =1  extern void          _nop_     (void);
  13      =1  extern bit           _testbit_ (bit);
  14      =1  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =1  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =1  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =1  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =1  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =1  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =1  extern unsigned char _chkfloat_(float);
  21      =1  extern void          _push_    (unsigned char _sfr);
  22      =1  extern void          _pop_     (unsigned char _sfr);
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 31  

  23      =1  
  24      =1  #endif
  25      =1  
  58          
  59          
  60          // Constants that define available card sizes, 8MB through 128MB  
             -                                     
  61          #define PS_8MB       8388608L
  62          #define PS_16MB      16777216L
  63          #define PS_32MB      33554432L
  64          #define PS_64MB      67108864L
  65          #define PS_128MB     134217728L
  66          
  67          #define ERROR_CODE      0xFFFF
  68          #define BUFFER_SIZE 16
  69          
  70          //#define NSSMD0 SLVSEL
  71          
  72          // Erase group size = 16 MMC FLASH sectors
  73          #define PHYSICAL_GROUP_SIZE     (PHYSICAL_BLOCK_SIZE * 16)
  74          
  75          // Command table value definitions
  76          // Used in the MMC_Command_Exec function to 
  77          // decode and execute MMC command requests
  78          #define     EMPTY  0
  79          #define     YES   1
  80          #define     NO    0
  81          #define     CMD   0
  82          #define     RD    1
  83          #define     WR    2
  84          #define     R1    0
  85          #define     R1b   1
  86          #define     R2    2
  87          #define     R3    3
  88          
  89          // Start and stop data tokens for single and multiple
  90          // block MMC data operations
  91          #define     START_SBR      0xFE
  92          #define     START_MBR      0xFE
  93          #define     START_SBW      0xFE
  94          #define     START_MBW      0xFC
  95          #define     STOP_MBW       0xFD
  96          
  97          // Mask for data response Token after an MMC write
  98          #define     DATA_RESP_MASK 0x11
  99          
 100          // Mask for busy Token in R1b response
 101          #define     BUSY_BIT       0x80
 102          
 103          // Command Table Index Constants:
 104          // Definitions for each table entry in the command table.
 105          // These allow the MMC_Command_Exec function to be called with a
 106          // meaningful parameter rather than a number.
 107          #define     GO_IDLE_STATE            0
 108          #define     SEND_OP_COND             1
 109          #define     SEND_CSD                 2
 110          #define     SEND_CID                 3
 111          #define     STOP_TRANSMISSION        4
 112          #define     SEND_STATUS              5
 113          #define     SET_BLOCKLEN             6
 114          #define     READ_SINGLE_BLOCK        7
 115          #define     READ_MULTIPLE_BLOCK      8
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 32  

 116          #define     WRITE_BLOCK              9
 117          #define     WRITE_MULTIPLE_BLOCK    10
 118          #define     PROGRAM_CSD             11
 119          #define     SET_WRITE_PROT          12
 120          #define     CLR_WRITE_PROT          13
 121          #define     SEND_WRITE_PROT         14
 122          #define     TAG_SECTOR_START        15
 123          #define     TAG_SECTOR_END          16
 124          #define     UNTAG_SECTOR            17
 125          #define     TAG_ERASE_GROUP_START   18
 126          #define     TAG_ERASE_GROUP_END     19
 127          #define     UNTAG_ERASE_GROUP       20
 128          #define     ERASE                   21
 129          #define     LOCK_UNLOCK             22
 130          #define     READ_OCR                23
 131          #define     CRC_ON_OFF              24
 132          
 133          //----------------------------------------------------------------
             --------------
 134          // UNIONs, STRUCTUREs, and ENUMs
 135          //----------------------------------------------------------------
             --------------
 136          typedef union LONG {                   // byte-addressable LONG
 137            long l;
 138            unsigned char b[4];
 139          } LONG;
 140          
 141          typedef union INT {                    // byte-addressable INT
 142            int i;
 143            unsigned char b[2];
 144          } INT;
 145          
 146          typedef union {                        // byte-addressable unsigne
             -d long
 147              unsigned long l;
 148              unsigned char b[4];
 149                        } ULONG;
 150          
 151          typedef union {                        // byte-addressable unsigne
             -d int
 152              unsigned int i;
 153              unsigned char b[2];
 154                        } UINT;
 155          
 156          // This structure defines entries into the command table;
 157          typedef struct {
 158              unsigned char command_byte;      // OpCode;
 159              unsigned char arg_required;      // Indicates argument require
             -ment;
 160              unsigned char CRC;               // Holds CRC for command if n
             -ecessary;
 161              unsigned char trans_type;        // Indicates command transfer
             - type;
 162              unsigned char response;          // Indicates expected respons
             -e;
 163              unsigned char var_length;        // Indicates varialble length
             - transfer;
 164                         } COMMAND;
 165          
 166          // Command table for MMC.  This table contains all commands availa
             -ble in SPI
 167          // mode;  Format of command entries is described above in command 
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 33  

             -structure
 168          // definition;
 169          COMMAND code command_list[25] = {
 170              { 0,NO ,0x95,CMD,R1 ,NO },    // CMD0;  GO_IDLE_STATE: reset c
             -ard;
 171              { 1,NO ,0xFF,CMD,R1 ,NO },    // CMD1;  SEND_OP_COND: initiali
             -ze card;
 172              { 9,NO ,0xFF,RD ,R1 ,NO },    // CMD9;  SEND_CSD: get card spe
             -cific data;
 173              {10,NO ,0xFF,RD ,R1 ,NO },    // CMD10; SEND_CID: get card ide
             -ntifier;
 174              {12,NO ,0xFF,CMD,R1 ,NO },    // CMD12; STOP_TRANSMISSION: end
             - read;
 175              {13,NO ,0xFF,CMD,R2 ,NO },    // CMD13; SEND_STATUS: read card
             - status;
 176              {16,YES,0xFF,CMD,R1 ,NO },    // CMD16; SET_BLOCKLEN: set bloc
             -k size;
 177              {17,YES,0xFF,RD ,R1 ,NO },    // CMD17; READ_SINGLE_BLOCK: rea
             -d 1 block;
 178              {18,YES,0xFF,RD ,R1 ,YES},    // CMD18; READ_MULTIPLE_BLOCK: r
             -ead > 1;
 179              {24,YES,0xFF,WR ,R1 ,NO },    // CMD24; WRITE_BLOCK: write 1 b
             -lock;
 180              {25,YES,0xFF,WR ,R1 ,YES},    // CMD25; WRITE_MULTIPLE_BLOCK: 
             -write > 1;
 181              {27,NO ,0xFF,CMD,R1 ,NO },    // CMD27; PROGRAM_CSD: program C
             -SD;
 182              {28,YES,0xFF,CMD,R1b,NO },    // CMD28; SET_WRITE_PROT: set wp
             - for group;
 183              {29,YES,0xFF,CMD,R1b,NO },    // CMD29; CLR_WRITE_PROT: clear 
             -group wp;
 184              {30,YES,0xFF,CMD,R1 ,NO },    // CMD30; SEND_WRITE_PROT: check
             - wp status;
 185              {32,YES,0xFF,CMD,R1 ,NO },    // CMD32; TAG_SECTOR_START: tag 
             -1st erase;
 186              {33,YES,0xFF,CMD,R1 ,NO },    // CMD33; TAG_SECTOR_END: tag en
             -d(single);
 187              {34,YES,0xFF,CMD,R1 ,NO },    // CMD34; UNTAG_SECTOR: deselect
             - for erase;
 188              {35,YES,0xFF,CMD,R1 ,NO },    // CMD35; TAG_ERASE_GROUP_START;
 189              {36,YES,0xFF,CMD,R1 ,NO },    // CMD36; TAG_ERASE_GROUP_END;
 190              {37,YES,0xFF,CMD,R1 ,NO },    // CMD37; UNTAG_ERASE_GROUP;
 191              {38,YES,0xFF,CMD,R1b,NO },    // CMD38; ERASE: erase all tagge
             -d sectors;
 192              {42,YES,0xFF,CMD,R1b,NO },    // CMD42; LOCK_UNLOCK;
 193              {58,NO ,0xFF,CMD,R3 ,NO },    // CMD58; READ_OCR: read OCR reg
             -ister;
 194              {59,YES,0xFF,CMD,R1 ,NO }    // CMD59; CRC_ON_OFF: toggles CRC
             - checking;
 195                                        };
 196          
 197          //----------------------------------------------------------------
             --------------
 198          // Global VARIABLES
 199          //----------------------------------------------------------------
             --------------
 200          
 201          // Removed these. It doesn't work correctly on every MMC card, and
             - we need
 202          // all the resources we can get.
 203          xdata unsigned long PHYSICAL_SIZE;     // MMC size variable;  Set 
             -during
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 34  

 204                                                 // initialization;
 205          
 206          xdata unsigned long PHYSICAL_BLOCKS;   // MMC block number;  Compu
             -ted during
 207                                                 // initialization;
 208          
 209          bdata bit Is_Initialized;
 210           
 211          xdata char LOCAL_BLOCK[BUFFER_SIZE]; 
 212          #define SEND__IN_FUNCTION
 213          
 214          #ifdef __F326_VER__ 
              static unsigned char Write_Read_Spi_Byte(unsigned char byte);
              #endif
 217          
 218          #ifdef SEND__IN_FUNCTION 
 219          static unsigned char Write_Read_Spi_Byte(unsigned char byte);
 220          #endif
 221          
 222          void Wait_ms(unsigned int count);
 223          void Wait_ns(unsigned int count);
 224          
 225          extern BYTE xdata Scratch[PHYSICAL_BLOCK_SIZE];
 226          extern READ_BYTES(unsigned char* pchar,unsigned int len);
 227          extern WRITE_BYTES(unsigned char* pchar,unsigned int len);
 228          
 229          #ifdef __F326_VER__ 
              #define BACK_FROM_ERROR \
              {\
                Write_Read_Spi_Byte(0xFF);\
                SCS = 1;\
                Write_Read_Spi_Byte(0xFF);\
                return ERROR_CODE; \
              }
              #else 
 238          #define BACK_FROM_ERROR \
 239          {\
 240            SPI0DAT = 0xFF; \
 241            while(!SPIF){} \
 242            SPIF = 0; \
 243            NSSMD0 = 1;\
 244            SPI0DAT = 0xFF;\
 245            while(!SPIF){}  \
 246            SPIF = 0;  \                      
 247            return ERROR_CODE; \
 248          }
 249          #endif 
 250                  
 251          
 252          //----------------------------------------------------------------
             -------------
 253          // SPI0_Init
 254          //----------------------------------------------------------------
             -------------
 255          //
 256          // Configure SPI0 for 8-bit, 2MHz SCK, Master mode, polled operati
             -on, data
 257          // sampled on 1st SCK rising edge.
 258          //
 259          // Parameters   :
 260          // Return Value :
 261          //----------------------------------------------------------------
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 35  

             -------------
 262          
 263          void SPI_Init (void)
 264          {
 265   1      #ifdef __F326_VER__
              #else
 267   1        Is_Initialized = 0;
 268   1        SPI0CFG = 0x70;                     // data sampled on rising ed
             -ge, clk
 269   1                                             // active low,
 270   1                                             // 8-bit data words, master
             - mode;
 271   1      
 272   1        SPI0CN = 0x0F;                      // 4-wire mode; SPI enabled;
             - flags
 273   1                                             // cleared
 274   1      
 275   1      #ifdef __F340_VER__
 276   1        SPI0CKR = 119;
 277   1        NSSMD0 = 1;
 278   1      #else
                SPI0CKR = SYSCLK/2/10000000;      //119;  // SPI clock <= 10MHz
              #endif
 281   1      #endif
 282   1      }
 283          
 284          sbit Led1 = P2^2;
 285          sbit Led2 = P2^3;
 286          
 287          
 288          
 289          #define MMC_Show_Activity() { if(Led1) { Led1=0;Led2=1;} else { Le
             -d1=1;Led2=0; } }
 290          
 291          //----------------------------------------------------------------
             --------------
 292          // MMC_Command_Exec
 293          //----------------------------------------------------------------
             --------------
 294          //
 295          // This function generates the necessary SPI traffic for all MMC S
             -PI commands.
 296          // The three parameters are described below:
 297          // 
 298          // Cmd:      This parameter is used to index into the command tabl
             -e and read
 299          //           the desired command.  The Command Table Index Constan
             -ts allow the
 300          //           caller to use a meaningful constant name in the Cmd p
             -arameter 
 301          //           instead of a simple index number.  For example, inste
             -ad of calling 
 302          //           MMC_Command_Exec (0, argument, pchar) to send the MMC
             - into idle 
 303          //           state, the user can call 
 304          //           MMC_Command_Exec (GO_IDLE_STATE, argument, pchar);
 305          //
 306          // argument: This parameter is used for MMC commands that require 
             -an argument.
 307          //           MMC arguments are 32-bits long and can be values such
             - as an
 308          //           an address, a block length setting, or register setti
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 36  

             -ngs for the
 309          //           MMC.
 310          //
 311          // pchar:    This parameter is a pointer to the local data locatio
             -n for MMC 
 312          //           data operations.  When a read or write occurs, data w
             -ill be stored
 313          //           or retrieved from the location pointed to by pchar.
 314          //
 315          // The MMC_Command_Exec function indexes the command table using t
             -he Cmd 
 316          // parameter. It reads the command table entry into memory and use
             -s information
 317          // from that entry to determine how to proceed.  Returns the 16-bi
             -t card 
 318          // response value;
 319          //
 320          
 321          unsigned int MMC_Command_Exec (unsigned char cmd_loc, unsigned lon
             -g argument,
 322                                     unsigned char *pchar)
 323          {
 324   1        xdata unsigned char loopguard;
 325   1        idata COMMAND current_command;      // Local space for the comma
             -nd table 
 326   1                                             // entry;
 327   1        idata ULONG long_arg;               // Union variable for easy b
             -yte 
 328   1                                             // transfers of the argumen
             -t;
 329   1                                             // Static variable that hol
             -ds the 
 330   1                                             // current data block lengt
             -h;
 331   1        static xdata unsigned int current_blklen = 512;
 332   1        unsigned long xdata old_blklen = 512;     // Temp variable to pr
             -eserve data block
 333   1                                             // length during temporary 
             -changes;
 334   1        idata unsigned int counter = 0;     // Byte counter for multi-by
             -te fields;
 335   1        idata UINT card_response;           // Variable for storing card
             - response;
 336   1        idata unsigned char data_resp;      // Variable for storing data
             - response;
 337   1        idata unsigned char dummy_CRC;      // Dummy variable for storin
             -g CRC field;
 338   1        unsigned char *plast; 
 339   1         
 340   1      //   xdata unsigned char c;
 341   1                                           
 342   1        current_command = command_list[cmd_loc]; // Retrieve desired com
             -mand table entry
 343   1                                                                                      // from code space;
 344   1        card_response.i = 0;
 345   1      #ifdef __F326_VER__
                Write_Read_Spi_Byte(0xFF);
                SCS = 0;
                Write_Read_Spi_Byte(0xFF);
                Write_Read_Spi_Byte(current_command.command_byte | 0x40);
              #else
 351   1      #ifdef SEND__IN_FUNCTION
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 37  

 352   1        Write_Read_Spi_Byte(0xFF);
 353   1        NSSMD0 = 0;
 354   1        Write_Read_Spi_Byte(0xFF);
 355   1        Write_Read_Spi_Byte(current_command.command_byte | 0x40);
 356   1      #else
              
                SPI0DAT = 0xFF;                     // Send buffer SPI clocks to
             - ensure no
                while(!SPIF){}                      // MMC operations are pendin
             -g;
                SPIF = 0;
                NSSMD0 = 0;                         // Select MMC by pulling CS 
             -low;
                SPI0DAT = 0xFF;                     // Send another byte of SPI 
             -clocks;
                while(!SPIF){}
                SPIF = 0;
                                                     // Issue command opcode;
                SPI0DAT = (current_command.command_byte | 0x40);
              #endif
 368   1      #endif
 369   1        long_arg.l = argument;              // Make argument byte addres
             -sable;
 370   1                                            // If current command change
             -s block
 371   1                                            // length, update block leng
             -th variable
 372   1                                            // to keep track;
 373   1                                            // Command byte = 16 means t
             -hat a set
 374   1                                            // block length command is t
             -aking place
 375   1                                            // and block length variable
             - must be
 376   1                                            // set;
 377   1        if(current_command.command_byte == 16) {
 378   2          current_blklen = argument;       
 379   2        }                                
 380   1                                             // Command byte = 9 or 10 m
             -eans that a
 381   1                                             // 16-byte register value i
             -s being read
 382   1                                             // from the card, block len
             -gth must be
 383   1                                             // set to 16 bytes, and res
             -tored at the
 384   1                                             // end of the transfer;
 385   1        if((current_command.command_byte == 9)||
 386   1           (current_command.command_byte == 10)) {
 387   2          old_blklen = current_blklen;     // Command is a GET_CSD or GE
             -T_CID,
 388   2          current_blklen = 16;             // set block length to 16-byt
             -es;
 389   2        }
 390   1      
 391   1      #ifndef __F326_VER__
 392   1      #ifdef SEND__IN_FUNCTION
 393   1      #else
                while(!SPIF){}                      // Wait for initial SPI tran
             -sfer to end;
                SPIF = 0;                           // Clear SPI Interrupt flag;
              #endif
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 38  

 397   1      #endif
 398   1      
 399   1                                             // If an argument is requir
             -ed, transmit
 400   1                                             // one, otherwise transmit 
             -4 bytes of
 401   1                                             // 0x00;
 402   1        plast = &pchar[current_blklen];
 403   1        if(current_command.arg_required == YES) {
 404   2          counter = 0;
 405   2          while(counter <= 3) {
 406   3      #ifdef __F326_VER__     
                                Write_Read_Spi_Byte(long_arg.b[counter]);
                                counter++;
              #else
 410   3      #ifdef SEND__IN_FUNCTION
 411   3                  Write_Read_Spi_Byte(long_arg.b[counter]);
 412   3                  counter++;
 413   3      #else
                    SPI0DAT = long_arg.b[counter];
                    counter++;
                    while(!SPIF){}
                    SPIF = 0;
              #endif
 419   3      #endif
 420   3          }
 421   2        } else {
 422   2          counter = 0;
 423   2          while(counter <= 3) {
 424   3      #ifdef __F326_VER__     
                    Write_Read_Spi_Byte(0x00);
                                counter++;
              #else
 428   3      #ifdef SEND__IN_FUNCTION
 429   3            Write_Read_Spi_Byte(0x00);
 430   3            counter++;
 431   3      #else
                    SPI0DAT = 0x00;
                    counter++;
                    while(!SPIF){}
                    SPIF = 0;
              #endif
 437   3      #endif
 438   3          }
 439   2        }
 440   1      #ifdef __F326_VER__     
                Write_Read_Spi_Byte(current_command.CRC);
              #else
 443   1      #ifdef SEND__IN_FUNCTION
 444   1        Write_Read_Spi_Byte(current_command.CRC);
 445   1      #else
                SPI0DAT = current_command.CRC;      // Transmit CRC byte;  In al
             -l cases
                while(!SPIF){}                      // except CMD0, this will be
             - a dummy
                SPIF = 0;                           // character;
              #endif
 450   1      #endif
 451   1                                             // The command table entry 
             -will indicate
 452   1                                             // what type of response to
             - expect for
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 39  

 453   1                                             // a given command;  The fo
             -llowing 
 454   1                                             // conditional handles the 
             -MMC response;
 455   1        if(current_command.response == R1) { // Read the R1 response fro
             -m the card;
 456   2          loopguard=0;
 457   2          do {
 458   3      #ifdef __F326_VER__
                    card_response.b[0] = Write_Read_Spi_Byte(0xFF);
              #else
 461   3      
 462   3      #ifdef SEND__IN_FUNCTION
 463   3                        card_response.b[0] = Write_Read_Spi_Byte(0xFF);
 464   3      #else
                    SPI0DAT = 0xFF;               // Write dummy value to SPI so
             - that 
                    while(!SPIF){}                // the response byte will be s
             -hifted in;
                    SPIF = 0;
                    card_response.b[0] = SPI0DAT; // Save the response;
              #endif
 470   3      #endif
 471   3      
 472   3            if(!++loopguard) break;
 473   3            if(card_response.b[0] & BUSY_BIT) { 
 474   4                       //     printf("R1 response 0x%02bX\r\n",card_response.b[0]);
 475   4              Wait_ns(700);
 476   4                        }
 477   3          } while((card_response.b[0] & BUSY_BIT));
 478   2                if(!loopguard) { 
 479   3          /*printf("R1 response 0x%02bX\r\n",card_response.b[0]);*/
 480   3            return card_response.b[0];}//{ return 0; }
 481   2          }                                     // Read the R1b response
             -;
 482   1          else if(current_command.response == R1b) {
 483   2            loopguard = 0;    
 484   2            do {
 485   3      #ifdef __F326_VER__
                      card_response.b[0] = Write_Read_Spi_Byte(0xFF);
              #else
 488   3      #ifdef SEND__IN_FUNCTION
 489   3              card_response.b[0] = Write_Read_Spi_Byte(0xFF);
 490   3      #else
                      SPI0DAT = 0xFF;               // Start SPI transfer;
                      while(!SPIF){}
                      SPIF = 0;
                      card_response.b[0] = SPI0DAT; // Save card response
              #endif
 496   3      #endif
 497   3              if(!++loopguard) break;
 498   3            }
 499   2            while((card_response.b[0] & BUSY_BIT));
 500   2      #ifdef __F326_VER__
                    while(Write_Read_Spi_Byte(0xff) == 0x00);
              #else
 503   2      #ifdef SEND__IN_FUNCTION
 504   2                  while(Write_Read_Spi_Byte(0xff) == 0x00);
 505   2      #else
                    loopguard = 0;
                    do {                              // Wait for busy signal to
             - end;
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 40  

                      SPI0DAT = 0xFF;               
                      while(!SPIF){}
                      SPIF = 0;
                                if(!++loopguard) break;
                    } while(SPI0DAT == 0x00);          // When byte from card is
             - non-zero,
                          if(!loopguard) {BACK_FROM_ERROR;}
              #endif
 515   2      #endif
 516   2          }                                   // card is no longer busy;
 517   1                                             // Read R2 response
 518   1          else if(current_command.response == R2) {
 519   2            loopguard=0;
 520   2            do {
 521   3      #ifdef __F326_VER__
                                  card_response.b[0] = Write_Read_Spi_Byte(0xFF);
              #else
 524   3      #ifdef SEND__IN_FUNCTION
 525   3              card_response.b[0] = Write_Read_Spi_Byte(0xFF);
 526   3      #else
                      SPI0DAT = 0xFF;               // Start SPI transfer;
                      while(!SPIF){}
                      SPIF = 0;
                      card_response.b[0] = SPI0DAT; // Read first byte of respon
             -se;
              #endif
 532   3      #endif
 533   3              if(!++loopguard) break;
 534   3            } while((card_response.b[0] & BUSY_BIT));
 535   2      
 536   2                  if(!loopguard) { BACK_FROM_ERROR; }
 537   2      #ifdef __F326_VER__
                          card_response.b[1] = Write_Read_Spi_Byte(0xFF);
              #else
 540   2      #ifdef SEND__IN_FUNCTION
 541   2            card_response.b[1] = Write_Read_Spi_Byte(0xFF);
 542   2      #else
                    SPI0DAT = 0xFF;
                    while(!SPIF){}
                    SPIF = 0;
                    card_response.b[1] = SPI0DAT;    // Read second byte of resp
             -onse;
              #endif
 548   2      #endif
 549   2          } else {                               // Read R3 response;
 550   2            loopguard=0;
 551   2            do {
 552   3      #ifdef __F326_VER__
                      card_response.b[0] = Write_Read_Spi_Byte(0xFF);
              #else
 555   3      #ifdef SEND__IN_FUNCTION
 556   3              card_response.b[0] = Write_Read_Spi_Byte(0xFF);
 557   3      #else
                      SPI0DAT = 0xFF;               // Start SPI transfer;
                      while(!SPIF){}
                      SPIF = 0;
                      card_response.b[0] = SPI0DAT; // Read first byte of respon
             -se;
              #endif
 563   3      #endif
 564   3                          if(!++loopguard) break;
 565   3            } while((card_response.b[0] & BUSY_BIT));
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 41  

 566   2        
 567   2                if(!loopguard) { BACK_FROM_ERROR; }
 568   2            counter = 0;
 569   2            while(counter <= 3)              // Read next three bytes an
             -d store them
 570   2            {                                // in local memory;  These 
             -bytes make up
 571   3              counter++;                    // the Operating Conditions 
             -Register
 572   3      #ifdef __F326_VER__
                            *pchar++ = Write_Read_Spi_Byte(0xFF);
              #else
 575   3      #ifdef SEND__IN_FUNCTION
 576   3              *pchar++ = Write_Read_Spi_Byte(0xFF);
 577   3      #else
                      SPI0DAT = 0xFF;               // (OCR);
                      while(!SPIF){}
                      SPIF = 0;
                      *pchar++ = SPI0DAT;
              #endif
 583   3      #endif
 584   3            }
 585   2          }
 586   1          switch(current_command.trans_type)  // This conditional handle
             -s all data 
 587   1          {                                   // operations;  The comman
             -d entry
 588   2                                             // determines what type, if
             - any, data
 589   2                                             // operations need to occur
             -;
 590   2            case RD:                         // Read data from the MMC;
 591   2                        loopguard = 0;
 592   2      #ifdef __F326_VER__
                            while(Write_Read_Spi_Byte(0xFF)!=START_SBR) {
                              if(!++loopguard) {BACK_FROM_ERROR;}
                            } 
              #else
 597   2      #ifdef SEND__IN_FUNCTION
 598   2                    while((Write_Read_Spi_Byte(0xFF))!=START_SBR) {
 599   3                Wait_ns(700);
 600   3                          if(!++loopguard) { 
 601   4                /*printf("RD Start response not set ");*/ 
 602   4                  BACK_FROM_ERROR;}
 603   3                      }       
 604   2      #else
                        do                            // Wait for a start read T
             -oken from
                        {                             // the MMC;
                                                                                         // Start a SPI transfer;
                                            SPI0DAT = 0xFF;            
                          while(!SPIF){}
                          SPIF = 0;
                                            if(!++loopguard) break;
                        } while(SPI0DAT != START_SBR);  // Check for a start rea
             -d Token;
                                    if(!loopguard) { BACK_FROM_ERROR; }
              #endif
 615   2      #endif
 616   2                      
 617   2                counter = 0;                  // Reset byte counter;
 618   2                                             // Read <current_blklen> by
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 42  

             -tes;
 619   2              //       START_SPI_TIMEOUT;
 620   2                            READ_BYTES(pchar,current_blklen);
 621   2              //       STOP_SPI_TIME_OUT;
 622   2                      
 623   2      #ifdef __F326_VER__
                                    dummy_CRC = Write_Read_Spi_Byte(0xFF);
              #else
 626   2      #ifdef SEND__IN_FUNCTION
 627   2                            dummy_CRC = Write_Read_Spi_Byte(0xFF);
 628   2      #else
                        SPI0DAT = 0xFF;               // After all data is read,
             - read the two
                        while(!SPIF){}                // CRC bytes;  These bytes
             - are not used
                        SPIF = 0;                     // in this mode, but the p
             -laceholders 
                        dummy_CRC = SPI0DAT;          // must be read anyway;
                        SPI0DAT = 0xFF;
                        while(!SPIF){}
                        SPIF = 0;
                        dummy_CRC = SPI0DAT;
              #endif
 638   2      #endif
 639   2                break;
 640   2              case WR: 
 641   2                
 642   2      #ifdef __F326_VER__
                        Write_Read_Spi_Byte(0xFF);
                        Write_Read_Spi_Byte(START_SBW);
              #else
 646   2      
 647   2      #ifdef SEND__IN_FUNCTION
 648   2                Write_Read_Spi_Byte(0xFF);
 649   2                Write_Read_Spi_Byte(START_SBW);
 650   2      #else                                                                           // Write data to the MMC;
                        SPI0DAT = 0xFF;               // Start by sending 8 SPI 
             -clocks so
                        while(!SPIF){}                // the MMC can prepare for
             - the write;
                        SPIF = 0;
                        SPI0DAT = START_SBW;          // Send the start write bl
             -ock Token;
                        while(!SPIF){}
                        SPIF = 0;
                                                                          // Reset byte counter;
                                                     // Write <current_blklen> b
             -ytes to MMC;
              #endif
 660   2                Wait_ns(700);
 661   2      #endif
 662   2      
 663   2                       //START_SPI_TIMEOUT;
 664   2              WRITE_BYTES(pchar,current_blklen);
 665   2                  // STOP_SPI_TIME_OUT;
 666   2              
 667   2      #ifdef __F326_VER__
                      Write_Read_Spi_Byte(0xFF);
                      Write_Read_Spi_Byte(0xFF);
              #else
 671   2      #ifdef SEND__IN_FUNCTION
 672   2              Write_Read_Spi_Byte(0xFF);
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 43  

 673   2              Write_Read_Spi_Byte(0xFF);
 674   2      #else
                      SPI0DAT = 0xFF;               // Write CRC bytes (don't ca
             -res);
                      while(!SPIF){}
                      SPIF = 0;
                      SPI0DAT = 0xFF;
                      while(!SPIF){}
                      SPIF = 0;
              #endif
 682   2      #endif
 683   2              loopguard = 0;
 684   2              do                            // Read Data Response from c
             -ard;
 685   2              {  
 686   3      #ifdef __F326_VER__
                        data_resp = Write_Read_Spi_Byte(0xFF);
                        if(!++loopguard) break;
              #else
 690   3      #ifdef SEND__IN_FUNCTION
 691   3                data_resp = Write_Read_Spi_Byte(0xFF);
 692   3                if(!++loopguard) break;
 693   3      #else
                        SPI0DAT = 0xFF;
                        while(!SPIF){}
                        SPIF = 0;
                        data_resp = SPI0DAT;
                        if(!++loopguard) break;
              #endif
 700   3      #endif
 701   3              }                             // When bit 0 of the MMC res
             -ponse
 702   2                                             // is clear, a valid data r
             -esponse
 703   2                                             // has been received;
 704   2              while((data_resp & DATA_RESP_MASK) != 0x01);
 705   2              if(!loopguard) { BACK_FROM_ERROR; }
 706   2      
 707   2      #ifdef __F326_VER__
                      while(Write_Read_Spi_Byte(0xFF)==0x00);
                      Write_Read_Spi_Byte(0xFF);
              #else
 711   2      #ifdef SEND__IN_FUNCTION
 712   2              while(Write_Read_Spi_Byte(0xFF)==0x00);
 713   2              Write_Read_Spi_Byte(0xFF);
 714   2      #else
                      do                            // Wait for end of busy sign
             -al;
                      {
                        SPI0DAT = 0xFF;            // Start SPI transfer to rece
             -ive
                        while(!SPIF){}             // busy tokens;
                        SPIF = 0;
                      } while(SPI0DAT == 0x00);       // When a non-zero Token i
             -s returned,
                                                     // card is no longer busy;
              
                      SPI0DAT = 0xFF;               // Issue 8 SPI clocks so tha
             -t all card
                      while(!SPIF){}                // operations can complete;
                      SPIF = 0;
              #endif
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 44  

 727   2      #endif
 728   2      
 729   2              break;
 730   2            default: break;
 731   2          }
 732   1      #ifdef __F326_VER__
                  Write_Read_Spi_Byte(0xFF);
                  SCS = 1;
                  Write_Read_Spi_Byte(0xFF);
              #else
 737   1      #ifdef SEND__IN_FUNCTION
 738   1          Write_Read_Spi_Byte(0xFF);
 739   1          NSSMD0 = 1;
 740   1          Write_Read_Spi_Byte(0xFF);
 741   1      #else
                  SPI0DAT = 0xFF;
                  while(!SPIF){}
                  SPIF = 0;
              
                  NSSMD0 = 1;                         // Deselect memory card;
                  SPI0DAT = 0xFF;                     // Send 8 more SPI clocks 
             -to ensure
                  while(!SPIF){}                      // the card has finished a
             -ll necessary
                  SPIF = 0;                           // operations;
                                                     // Restore old block length
             - if needed;
              #endif
 752   1      #endif
 753   1          if((current_command.command_byte == 9)||
 754   1            (current_command.command_byte == 10)) {
 755   2            current_blklen = old_blklen;
 756   2          }
 757   1          return card_response.i;
 758   1      }
 759          
 760          
 761          //----------------------------------------------------------------
             --------------
 762          // MMC_FLASH_Init
 763          //----------------------------------------------------------------
             --------------
 764          //
 765          // This function initializes the flash card, configures it to oper
             -ate in SPI
 766          // mode, and reads the operating conditions register to ensure tha
             -t the device
 767          // has initialized correctly.  It also determines the size of the 
             -card by 
 768          // reading the Card Specific Data Register (CSD).
 769          
 770          void MMC_FLASH_Init(void)
 771          {
 772   1        xdata unsigned loopguard;
 773   1        xdata int i;
 774   1        xdata UINT card_status;             // Stores card status return
             -ed from 
 775   1                                             // MMC function calls(MMC_C
             -ommand_Exec);
 776   1        xdata unsigned char counter = 0;    // SPI byte counter;
 777   1        unsigned char xdata *pchar;         // Xdata pointer for storing
             - MMC 
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 45  

 778   1                                             // register values;
 779   1                                             // Transmit at least 64 SPI
             - clocks
 780   1                                             // before any bus comm occu
             -rs.
 781   1      
 782   1        unsigned int c_size,bl_len;
 783   1        unsigned char c_mult;
 784   1      //      PHYSICAL_SIZE=0;
 785   1      //      PHYSICAL_BLOCKS=0;
 786   1      
 787   1        SPI_Init();
 788   1        Wait_ms(100);
 789   1        pchar = (unsigned char xdata*)LOCAL_BLOCK;
 790   1        for(counter = 0; counter < 8; counter++) {
 791   2      #ifdef __F326_VER__
                  Write_Read_Spi_Byte(0xFF);
              #else
 794   2      #ifdef SEND__IN_FUNCTION
 795   2          Write_Read_Spi_Byte(0xFF);
 796   2      #else
                  SPI0DAT = 0xFF;
                  while(!SPIF){}
                  SPIF = 0;
              #endif
 801   2      #endif
 802   2        }
 803   1        for(counter = 0; counter < 2; counter++) {
 804   2      #ifdef __F326_VER__
                  Write_Read_Spi_Byte(0xFF);
              #else
 807   2      #ifdef SEND__IN_FUNCTION
 808   2          Write_Read_Spi_Byte(0xFF);
 809   2      #else
                  SPI0DAT = 0xFF;
                  while(!SPIF){}
                  SPIF = 0;
              #endif
 814   2      #endif
 815   2        }
 816   1        
 817   1      #ifdef __F326_VER__
                SCS = 0;
              #else
 820   1        NSSMD0 = 0;                         // Select the MMC with the C
             -S pin;
 821   1                                             // Send 16 more SPI clocks 
             -to 
 822   1                                             // ensure proper startup;
 823   1      #endif
 824   1                                             // Send the GO_IDLE_STATE c
             -ommand with
 825   1                                             // CS driven low;  This cau
             -ses the MMC
 826   1                                             // to enter SPI mode;    
 827   1        Wait_ms(1);
 828   1        card_status.i = MMC_Command_Exec(GO_IDLE_STATE,EMPTY,EMPTY);
 829   1      
 830   1        loopguard=0;
 831   1      
 832   1                                             // Send the SEND_OP_COND co
             -mmand
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 46  

 833   1        do                                  // until the MMC indicates t
             -hat it is
 834   1        {         
 835   2      
 836   2          Wait_ms(1);
 837   2          card_status.i = MMC_Command_Exec(SEND_OP_COND,EMPTY,EMPTY);
 838   2          if(!++loopguard) break;
 839   2        } while ((card_status.b[0] & 0x01));
 840   1        printf("count SEND_OP_COND: %d\n",loopguard);
 841   1      
 842   1        if(!loopguard) return;
 843   1      
 844   1      #ifdef __F326_VER__
                Write_Read_Spi_Byte(0xFF);
              #else
 847   1      
 848   1      #ifdef SEND__IN_FUNCTION
 849   1        Write_Read_Spi_Byte(0xFF);
 850   1      #else
                SPI0DAT = 0xFF;                     // Send 8 more SPI clocks to
             - complete
                while(!SPIF){}                      // the initialization sequen
             -ce;
                SPIF = 0;
              #endif
 855   1      #endif
 856   1        loopguard=0;
 857   1      
 858   1        do                                  // Read the Operating Condit
             -ions 
 859   1        {                                   // Register (OCR);
 860   2          card_status.i = MMC_Command_Exec(READ_OCR,EMPTY,pchar);
 861   2          if(!++loopguard) break;
 862   2        } while(!(*pchar&0x80));              // Check the card busy bit
             - of the OCR;
 863   1        if(!loopguard) return;
 864   1      
 865   1        card_status.i = MMC_Command_Exec(SEND_STATUS,EMPTY,EMPTY);
 866   1                                             // Get the Card Specific Da
             -ta (CSD)
 867   1                                             // register to determine th
             -e size of the
 868   1                                             // MMC;
 869   1        for(i=0;i<4;i++) {
 870   2          printf("0x%02bX ",pchar[i]);
 871   2        }
 872   1      
 873   1        card_status.i = MMC_Command_Exec(SEND_CSD,EMPTY,pchar);
 874   1              
 875   1        if(card_status.i==0) {
 876   2          printf("Change speed");
 877   2          for(i=0;i<16;i++) {
 878   3            printf("0x%02bX ",pchar[i]);
 879   3          }
 880   2              #ifdef F340_M24
                  SPI0CKR = 0;
                      #else
 883   2          SPI0CKR = 1;
 884   2              #endif
 885   2          Wait_ms(1);
 886   2        } else {
 887   2          printf("CARD STATUS 0x%02X:\n",card_status.i);
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 47  

 888   2              for(i=0;i<16;i++) {
 889   3            printf("0x%02bX ",pchar[i]);
 890   3          }
 891   2          PHYSICAL_BLOCKS = 0;
 892   2          PHYSICAL_SIZE = PHYSICAL_BLOCKS * bl_len;
 893   2          return;
 894   2        }
 895   1      
 896   1        card_status.i = MMC_Command_Exec(SET_BLOCKLEN,(unsigned long)PHY
             -SICAL_BLOCK_SIZE,EMPTY);
 897   1      
 898   1        bl_len = 1 << (pchar[5] & 0x0f) ;
 899   1        c_size = ((pchar[6] & 0x03) << 10) | 
 900   1                              (pchar[7] << 2) | ((pchar[8] &0xc0) >> 6);
 901   1        c_mult = (((pchar[9] & 0x03) << 1) | ((pchar[10] & 0x80) >> 7));
 902   1        
 903   1                                             // Determine the number of 
             -MMC sectors;
 904   1        PHYSICAL_BLOCKS = (unsigned long)(c_size+1)*(1 << (c_mult+2));
 905   1        PHYSICAL_SIZE = PHYSICAL_BLOCKS * bl_len;
 906   1      
 907   1        loopguard = 0;
 908   1      
 909   1        while((MMC_FLASH_Block_Read(0,Scratch)!=0)) {
 910   2          if(!++loopguard) break;
 911   2        } 
 912   1        //printf("Wrong reads %d\n",loopguard);
 913   1      
 914   1        Is_Initialized = 1;
 915   1              
 916   1        Led1=0;Led2=0;
 917   1      }
 918          
 919          //----------------------------------------------------------------
             --------------
 920          // MMC_FLASH_Block_Read
 921          //----------------------------------------------------------------
             --------------
 922          //
 923          // If you know beforehand that you'll read an entire 512-byte bloc
             -k, then
 924          // this function has a smaller ROM footprint than MMC_FLASH_Read.
 925          //
 926          // Parameters   : address - address of block
 927          //                                pchar - pointer to byte 
 928          // Return Value : card status
 929          //----------------------------------------------------------------
             -------------
 930          
 931          unsigned int MMC_FLASH_Block_Read(unsigned long address, unsigned 
             -char *pchar) 
 932          {
 933   1        xdata unsigned int card_status;     // Stores MMC status after e
             -ach MMC command;
 934   1        address *= PHYSICAL_BLOCK_SIZE;
 935   1        Led1=1;
 936   1      /*      card_status = MMC_Command_Exec(SET_BLOCKLEN,(unsigned long)PHYS
             -ICAL_BLOCK_SIZE,EMPTY);
 937   1        if(card_status!=0) {
 938   1          printf("Read Address 0x%02LX\r\n",address);
 939   1          printf("Reading ERROR during set blocklen 0x%02BX\n",card_stat
             -us);
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 48  

 940   1          return card_status;
 941   1        }*/
 942   1        card_status = MMC_Command_Exec(READ_SINGLE_BLOCK,address,pchar);
 943   1              /*if(card_status!=0) {
 944   1          printf("Read Address 0x%02LX\r\n",address);
 945   1          printf("Reading ERROR during reading data 0x%02BX\n",card_stat
             -us);
 946   1              }*/
 947   1              Led1=0;
 948   1              return card_status;
 949   1      }
 950          
 951          //----------------------------------------------------------------
             --------------
 952          // MMC_FLASH_Block_Write
 953          //----------------------------------------------------------------
             --------------
 954          //
 955          // If you know beforehand that you'll write an entire 512-byte blo
             -ck, then
 956          // this function is more RAM-efficient than MMC_FLASH_Write becaus
             -e it 
 957          // doesn't require a 512-byte Scratch buffer (and it's faster too,
             - it doesn't
 958          // require a read operation first). And it has a smaller ROM footp
             -rint too.
 959          //
 960          // Parameters   : address - address of block
 961          //                                wdata - pointer to data 
 962          // Return Value : card status
 963          //----------------------------------------------------------------
             -------------
 964          
 965          unsigned char MMC_FLASH_Block_Write(unsigned long address,unsigned
             - char *wdata) 
 966          {
 967   1        xdata unsigned int card_status;     // Stores status returned fr
             -om MMC;
 968   1      
 969   1        address *= PHYSICAL_BLOCK_SIZE;
 970   1        Led2=1;
 971   1        card_status = MMC_Command_Exec(WRITE_BLOCK,address ,wdata);
 972   1        Led2=0;
 973   1        return card_status;
 974   1      }
 975          
 976          
 977          #ifdef __F326_VER__
              
              //----------------------------------------------------------------
             -------------
              // Write_Read_Spi_Byte
              //----------------------------------------------------------------
             -------------
              //
              // Function sends one byte to spi and reads ony byte from spi
              // it will be written with SYSCLK as clk
              //
              // Parameters   : byte - value to write
              // Return Value : SPI byte
              //----------------------------------------------------------------
             -------------
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 49  

              
              
              unsigned char Write_Read_Spi_Byte(unsigned char byte)
              {
                unsigned char i,ret = 0;
                for(i=0;i<8;i++) {
                  MOSI = (byte & 0x80) ? 1 : 0;
                  SCLK = 0;   
                  byte <<= 1;
                  ret <<= 1;
                  SCLK = 1;
                  ret |= MISO;
                }
                return ret;
              }
              
              #endif
1006          
1007          
1008          #ifdef SEND__IN_FUNCTION
1009          
1010          //----------------------------------------------------------------
             -------------
1011          // Write_Read_Spi_Byte
1012          //----------------------------------------------------------------
             -------------
1013          //
1014          // Function sends one byte to spi and reads ony byte from spi
1015          // it will be written with SYSCLK as clk
1016          //
1017          // Parameters   : byte - value to write
1018          // Return Value : SPI byte
1019          //----------------------------------------------------------------
             -------------
1020          
1021          unsigned char Write_Read_Spi_Byte(unsigned char byte)
1022          {
1023   1        unsigned char xdata ret;
1024   1        SPI0DAT = byte;
1025   1        while(!SPIF);                      
1026   1        SPIF = 0;
1027   1        ret = SPI0DAT;
1028   1        return ret;
1029   1      }
1030          
1031          #endif
1032          
1033          //----------------------------------------------------------------
             -------------
1034          // Wait_ms
1035          //----------------------------------------------------------------
             -------------
1036          //
1037          // Delay function with declared wait time in milliseconds
1038          //
1039          // Parameters   : count - time in ms
1040          // Return Value :
1041          //----------------------------------------------------------------
             -------------
1042          
1043          void Wait_ms(unsigned int count)
1044          {
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 50  

1045   1        int xdata i,j;
1046   1        for(i=0;i<count;i++) {
1047   2          for(j=0;j<1000;j++) {
1048   3            Wait_ns(1000);
1049   3          }
1050   2        }
1051   1      }
1052          
1053          //----------------------------------------------------------------
             -------------
1054          // Wait_ns
1055          //----------------------------------------------------------------
             -------------
1056          //
1057          // Delay function with declared wait time in nanoseconds
1058          //
1059          // Parameters   : count - time in ns
1060          // Return Value :
1061          //----------------------------------------------------------------
             -------------
1062          
1063          void Wait_ns(unsigned int count)
1064          {
1065   1      
1066   1      #ifdef F340_M24
                count/=40;
              #else
1069   1        count/=20;
1070   1      #endif
1071   1      
1072   1        while(count--) ;
1073   1      }
1074          
1075          //----------------------------------------------------------------
             -------------
1076          // Get_Status_MMC
1077          //----------------------------------------------------------------
             -------------
1078          //
1079          // Function returns the status of MMC card
1080          //
1081          // Parameters   : 
1082          // Return Value :
1083          //----------------------------------------------------------------
             -------------
1084          
1085          #ifdef __F340_VER__
1086          void Get_Status_MMC()
1087          {
1088   1        int xdata status= MMC_Command_Exec(SEND_STATUS,EMPTY,EMPTY);  
1089   1        printf("MMC Card Status 0x%02X",status);
1090   1      }
1091          
1092          #endif
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 51  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0088 (BEGIN)
0000         L?0137:
0000         L?0138:
0000 7B00              MOV     R3,#00H
0002 7A00              MOV     R2,#00H
0004 7900              MOV     R1,#00H
0006         L?0139:
0006 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+05H
0009 020000      E     LJMP    ?C?PSTXDATA
000C         L?0142:
000C         L?0143:
000C 900000      R     MOV     DPTR,#loopguard
000F         L?0144:
000F E4                CLR     A
0010 75F001            MOV     B,#01H
0013 020000      E     LJMP    ?C?IILDX
0016         L?0146:
0016 900000      R     MOV     DPTR,#bl_len
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E E4                CLR     A
001F FC                MOV     R4,A
0020 FD                MOV     R5,A
0021 900000      R     MOV     DPTR,#PHYSICAL_BLOCKS
0024 120000      E     LCALL   ?C?LLDXDATA0
0027 120000      E     LCALL   ?C?LMUL
002A 900000      R     MOV     DPTR,#PHYSICAL_SIZE
002D 22                RET     
002E         L?0148:
002E         L?0149:
002E 900000      R     MOV     DPTR,#i
0031         L?0150:
0031 E0                MOVX    A,@DPTR
0032 FE                MOV     R6,A
0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 C3                CLR     C
0037 22                RET     
0038         L?0151:
0038         L?0152:
0038 900000      R     MOV     DPTR,#pchar
003B 120000      E     LCALL   ?C?PLDXDATA
003E 900000      R     MOV     DPTR,#current_blklen
0041 E0                MOVX    A,@DPTR
0042 22                RET     
0043         L?0153:
0043         L?0154:
0043 E4                CLR     A
0044 7800        R     MOV     R0,#LOW counter
0046 F6                MOV     @R0,A
0047 08                INC     R0
0048 F6                MOV     @R0,A
0049 22                RET     
004A         L?0155:
004A         L?0156:
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 52  

004A C2FF              CLR     SPIF
004C D2FA              SETB    NSSMD0
004E 75A3FF            MOV     SPI0DAT,#0FFH
0051 22                RET     
0052         L?0157:
0052         L?0158:
0052 900000      R     MOV     DPTR,#pchar
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 22                RET     
005A         L?0161:
005A 120000      E     LCALL   ?C?LLDXDATA
005D E4                CLR     A
005E FB                MOV     R3,A
005F 7A02              MOV     R2,#02H
0061 F9                MOV     R1,A
0062 F8                MOV     R0,A
0063 020000      E     LJMP    ?C?LMUL
0066         L?0162:
0066 120000      E     LCALL   ?C?LLDXDATA
0069 900000      R     MOV     DPTR,#current_blklen
006C EE                MOV     A,R6
006D F0                MOVX    @DPTR,A
006E A3                INC     DPTR
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
0071 22                RET     
0072         L?0163:
0072         L?0164:
0072 E4                CLR     A
0073 900000      R     MOV     DPTR,#loopguard
0076 F0                MOVX    @DPTR,A
0077 A3                INC     DPTR
0078 F0                MOVX    @DPTR,A
0079 22                RET     
007A         L?0168:
007A D3                SETB    C
007B 7800        R     MOV     R0,#LOW counter+01H
007D E6                MOV     A,@R0
007E 9403              SUBB    A,#03H
0080 18                DEC     R0
0081 E6                MOV     A,@R0
0082 9400              SUBB    A,#00H
0084 22                RET     
0085         L?0169:
0085 120000      E     LCALL   ?C?LLDXDATA
0088 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
008B 020000      E     LJMP    ?C?LSTXDATA
             ; FUNCTION Com0088 (END)

             ; FUNCTION SPI_Init (BEGIN)
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 267
0000 C200        R     CLR     Is_Initialized
                                           ; SOURCE LINE # 268
0002 75A170            MOV     SPI0CFG,#070H
                                           ; SOURCE LINE # 272
0005 75F80F            MOV     SPI0CN,#0FH
                                           ; SOURCE LINE # 276
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 53  

0008 75A277            MOV     SPI0CKR,#077H
                                           ; SOURCE LINE # 277
000B D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 282
000D 22                RET     
             ; FUNCTION SPI_Init (END)

             ; FUNCTION _MMC_Command_Exec (BEGIN)
                                           ; SOURCE LINE # 321
;---- Variable 'cmd_loc' assigned to Register 'R3' ----
0000 AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 332
0002 900000      R     MOV     DPTR,#old_blklen
0005 120000      E     LCALL   ?C?LSTKXDATA
0008 00                DB      00H
0009 00                DB      00H
000A 02                DB      02H
000B 00                DB      00H
                                           ; SOURCE LINE # 334
000C 120000      R     LCALL   L?0153
                                           ; SOURCE LINE # 342
000F EB                MOV     A,R3
0010 75F006            MOV     B,#06H
0013 A4                MUL     AB
0014 2400        R     ADD     A,#LOW command_list
0016 F9                MOV     R1,A
0017 7400        R     MOV     A,#HIGH command_list
0019 35F0              ADDC    A,B
001B FA                MOV     R2,A
001C 7BFF              MOV     R3,#0FFH
001E 7800        R     MOV     R0,#LOW current_command
0020 7C00        R     MOV     R4,#HIGH current_command
0022 7D00              MOV     R5,#00H
0024 7E00              MOV     R6,#00H
0026 7F06              MOV     R7,#06H
0028 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 344
002B E4                CLR     A
002C 7800        R     MOV     R0,#LOW card_response
002E F6                MOV     @R0,A
002F 08                INC     R0
0030 F6                MOV     @R0,A
                                           ; SOURCE LINE # 352
0031 7FFF              MOV     R7,#0FFH
0033 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 353
0036 C2FA              CLR     NSSMD0
                                           ; SOURCE LINE # 354
0038 7FFF              MOV     R7,#0FFH
003A 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 355
003D 7800        R     MOV     R0,#LOW current_command
003F E6                MOV     A,@R0
0040 4440              ORL     A,#040H
0042 FF                MOV     R7,A
0043 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 369
0046 900000      R     MOV     DPTR,#argument
0049 120000      E     LCALL   ?C?LLDXDATA
004C 7800        R     MOV     R0,#LOW long_arg
004E 120000      E     LCALL   ?C?LSTIDATA
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 54  

                                           ; SOURCE LINE # 377
0051 7800        R     MOV     R0,#LOW current_command
0053 E6                MOV     A,@R0
0054 FB                MOV     R3,A
0055 B41006            CJNE    A,#010H,?C0002
                                           ; SOURCE LINE # 378
0058 900000      R     MOV     DPTR,#argument
005B 120000      R     LCALL   L?0162
                                           ; SOURCE LINE # 379
005E         ?C0002:
                                           ; SOURCE LINE # 385
005E EB                MOV     A,R3
005F 6409              XRL     A,#09H
0061 6006              JZ      ?C0004
0063 7800        R     MOV     R0,#LOW current_command
0065 E6                MOV     A,@R0
0066 B40A1A            CJNE    A,#0AH,?C0003
0069         ?C0004:
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0069 900000      R     MOV     DPTR,#current_blklen
006C E0                MOVX    A,@DPTR
006D FE                MOV     R6,A
006E A3                INC     DPTR
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
0071 E4                CLR     A
0072 FC                MOV     R4,A
0073 FD                MOV     R5,A
0074 900000      R     MOV     DPTR,#old_blklen
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 388
007A 900000      R     MOV     DPTR,#current_blklen
007D E4                CLR     A
007E F0                MOVX    @DPTR,A
007F A3                INC     DPTR
0080 7410              MOV     A,#010H
0082 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 389
0083         ?C0003:
                                           ; SOURCE LINE # 402
0083 120000      R     LCALL   L?0151
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 29                ADD     A,R1
008A F9                MOV     R1,A
008B EA                MOV     A,R2
008C 3E                ADDC    A,R6
008D FA                MOV     R2,A
008E 900000      R     MOV     DPTR,#plast
0091 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 403
0094 7800        R     MOV     R0,#LOW current_command+01H
0096 E6                MOV     A,@R0
0097 B40125            CJNE    A,#01H,?C0005
                                           ; SOURCE LINE # 404
009A 120000      R     LCALL   L?0153
009D         ?C0006:
                                           ; SOURCE LINE # 405
009D 7800        R     MOV     R0,#LOW counter
009F E6                MOV     A,@R0
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 55  

00A0 FE                MOV     R6,A
00A1 08                INC     R0
00A2 E6                MOV     A,@R0
00A3 FF                MOV     R7,A
00A4 D3                SETB    C
00A5 9403              SUBB    A,#03H
00A7 EE                MOV     A,R6
00A8 9400              SUBB    A,#00H
00AA 5028              JNC     ?C0008
                                           ; SOURCE LINE # 411
00AC 7400        R     MOV     A,#LOW long_arg
00AE 2F                ADD     A,R7
00AF F8                MOV     R0,A
00B0 E6                MOV     A,@R0
00B1 FF                MOV     R7,A
00B2 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 412
00B5 7800        R     MOV     R0,#LOW counter+01H
00B7 06                INC     @R0
00B8 E6                MOV     A,@R0
00B9 18                DEC     R0
00BA 70E1              JNZ     ?C0006
00BC 06                INC     @R0
00BD         ?C0121:
                                           ; SOURCE LINE # 420
00BD 80DE              SJMP    ?C0006
                                           ; SOURCE LINE # 421
00BF         ?C0005:
                                           ; SOURCE LINE # 422
00BF 120000      R     LCALL   L?0154
00C2         ?C0009:
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 429
00C2 E4                CLR     A
00C3 FF                MOV     R7,A
00C4 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 430
00C7 7800        R     MOV     R0,#LOW counter+01H
00C9 06                INC     @R0
00CA E6                MOV     A,@R0
00CB 18                DEC     R0
00CC 7001              JNZ     ?C0122
00CE 06                INC     @R0
00CF         ?C0122:
                                           ; SOURCE LINE # 438
00CF 120000      R     LCALL   L?0168
00D2 40EE              JC      ?C0009
                                           ; SOURCE LINE # 439
00D4         ?C0008:
                                           ; SOURCE LINE # 444
00D4 7800        R     MOV     R0,#LOW current_command+02H
00D6 E6                MOV     A,@R0
00D7 FF                MOV     R7,A
00D8 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 455
00DB 7800        R     MOV     R0,#LOW current_command+04H
00DD E6                MOV     A,@R0
00DE 7028              JNZ     ?C0011
                                           ; SOURCE LINE # 456
00E0 900000      R     MOV     DPTR,#loopguard
00E3 F0                MOVX    @DPTR,A
00E4         ?C0014:
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 56  

                                           ; SOURCE LINE # 457
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 472
00E4 120000      R     LCALL   L?0140
00E7 600F              JZ      ?C0013
00E9         ?C0015:
                                           ; SOURCE LINE # 473
00E9 7800        R     MOV     R0,#LOW card_response
00EB E6                MOV     A,@R0
00EC 30E703            JNB     ACC.7,?C0012
                                           ; SOURCE LINE # 475
00EF 120000      R     LCALL   L?0165
                                           ; SOURCE LINE # 476
                                           ; SOURCE LINE # 477
00F2         ?C0012:
00F2 7800        R     MOV     R0,#LOW card_response
00F4 E6                MOV     A,@R0
00F5 20E7EC            JB      ACC.7,?C0014
00F8         ?C0013:
                                           ; SOURCE LINE # 478
00F8 900000      R     MOV     DPTR,#loopguard
00FB E0                MOVX    A,@DPTR
00FC 6003              JZ      $ + 5H
00FE 020000      R     LJMP    ?C0019
                                           ; SOURCE LINE # 480
0101 7800        R     MOV     R0,#LOW card_response
0103 E6                MOV     A,@R0
0104 FF                MOV     R7,A
0105 7E00              MOV     R6,#00H
0107 22                RET     
                                           ; SOURCE LINE # 481
0108         ?C0011:
                                           ; SOURCE LINE # 482
0108 7800        R     MOV     R0,#LOW current_command+04H
010A E6                MOV     A,@R0
010B 6401              XRL     A,#01H
010D 7019              JNZ     ?C0020
                                           ; SOURCE LINE # 483
010F 900000      R     MOV     DPTR,#loopguard
0112 F0                MOVX    @DPTR,A
0113         ?C0023:
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 489
                                           ; SOURCE LINE # 497
0113 120000      R     LCALL   L?0140
0116 6006              JZ      ?C0025
                                           ; SOURCE LINE # 498
0118         ?C0021:
                                           ; SOURCE LINE # 499
0118 7800        R     MOV     R0,#LOW card_response
011A E6                MOV     A,@R0
011B 20E7F5            JB      ACC.7,?C0023
011E         ?C0025:
                                           ; SOURCE LINE # 504
011E 120000      R     LCALL   L?0170
0121 6003              JZ      $ + 5H
0123 020000      R     LJMP    ?C0019
0126 80F6              SJMP    ?C0025
                                           ; SOURCE LINE # 516
0128         ?C0020:
                                           ; SOURCE LINE # 518
0128 7800        R     MOV     R0,#LOW current_command+04H
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 57  

012A E6                MOV     A,@R0
012B 6402              XRL     A,#02H
012D 702F              JNZ     ?C0028
                                           ; SOURCE LINE # 519
012F 900000      R     MOV     DPTR,#loopguard
0132 F0                MOVX    @DPTR,A
0133         ?C0031:
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 525
                                           ; SOURCE LINE # 533
0133 120000      R     LCALL   L?0147
0136 6006              JZ      ?C0030
                                           ; SOURCE LINE # 534
0138         ?C0029:
0138 7800        R     MOV     R0,#LOW card_response
013A E6                MOV     A,@R0
013B 20E7F5            JB      ACC.7,?C0031
013E         ?C0030:
                                           ; SOURCE LINE # 536
013E 900000      R     MOV     DPTR,#loopguard
0141 E0                MOVX    A,@DPTR
0142 700F              JNZ     ?C0033
0144 75A3FF            MOV     SPI0DAT,#0FFH
0147         ?C0034:
0147 30FFFD            JNB     SPIF,?C0034
014A         ?C0035:
014A 120000      R     LCALL   L?0155
014D         ?C0036:
014D 30FFFD            JNB     SPIF,?C0036
0150         ?C0037:
0150 020000      R     LJMP    ?C0134
0153         ?C0033:
                                           ; SOURCE LINE # 541
0153 7FFF              MOV     R7,#0FFH
0155 120000      R     LCALL   _Write_Read_Spi_Byte
0158 7800        R     MOV     R0,#LOW card_response+01H
015A A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 549
015C 8049              SJMP    ?C0019
015E         ?C0028:
                                           ; SOURCE LINE # 550
015E E4                CLR     A
015F 900000      R     MOV     DPTR,#loopguard
0162 F0                MOVX    @DPTR,A
0163         ?C0041:
                                           ; SOURCE LINE # 551
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 564
0163 120000      R     LCALL   L?0147
0166 6006              JZ      ?C0040
                                           ; SOURCE LINE # 565
0168         ?C0039:
0168 7800        R     MOV     R0,#LOW card_response
016A E6                MOV     A,@R0
016B 20E7F5            JB      ACC.7,?C0041
016E         ?C0040:
                                           ; SOURCE LINE # 567
016E 900000      R     MOV     DPTR,#loopguard
0171 E0                MOVX    A,@DPTR
0172 700F              JNZ     ?C0043
0174 75A3FF            MOV     SPI0DAT,#0FFH
0177         ?C0044:
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 58  

0177 30FFFD            JNB     SPIF,?C0044
017A         ?C0045:
017A 120000      R     LCALL   L?0155
017D         ?C0046:
017D 30FFFD            JNB     SPIF,?C0046
0180         ?C0047:
0180         ?C0132:
0180 020000      R     LJMP    ?C0134
0183         ?C0043:
                                           ; SOURCE LINE # 568
0183 120000      R     LCALL   L?0154
0186         ?C0048:
                                           ; SOURCE LINE # 569
0186 120000      R     LCALL   L?0168
0189 501C              JNC     ?C0019
                                           ; SOURCE LINE # 570
                                           ; SOURCE LINE # 571
018B 08                INC     R0
018C 06                INC     @R0
018D E6                MOV     A,@R0
018E 18                DEC     R0
018F 7001              JNZ     ?C0123
0191 06                INC     @R0
0192         ?C0123:
                                           ; SOURCE LINE # 576
0192 7FFF              MOV     R7,#0FFH
0194 120000      R     LCALL   _Write_Read_Spi_Byte
0197 900000      R     MOV     DPTR,#pchar
019A E4                CLR     A
019B 75F001            MOV     B,#01H
019E 120000      E     LCALL   ?C?PLDIXDATA
01A1 EF                MOV     A,R7
01A2 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 584
01A5 80DF              SJMP    ?C0048
                                           ; SOURCE LINE # 585
01A7         ?C0019:
                                           ; SOURCE LINE # 586
01A7 7800        R     MOV     R0,#LOW current_command+03H
01A9 E6                MOV     A,@R0
01AA 24FE              ADD     A,#0FEH
01AC 6044              JZ      ?C0059
01AE 04                INC     A
01AF 6003              JZ      $ + 5H
01B1 020000      R     LJMP    ?C0050
                                           ; SOURCE LINE # 587
                                           ; SOURCE LINE # 590
01B4         ?C0051:
                                           ; SOURCE LINE # 591
01B4 E4                CLR     A
01B5 900000      R     MOV     DPTR,#loopguard
01B8 F0                MOVX    @DPTR,A
01B9         ?C0052:
                                           ; SOURCE LINE # 598
01B9 120000      R     LCALL   L?0170
01BC 64FE              XRL     A,#0FEH
01BE 601A              JZ      ?C0053
                                           ; SOURCE LINE # 599
01C0 120000      R     LCALL   L?0165
                                           ; SOURCE LINE # 600
01C3 900000      R     MOV     DPTR,#loopguard
01C6 E0                MOVX    A,@DPTR
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 59  

01C7 04                INC     A
01C8 F0                MOVX    @DPTR,A
01C9 70EE              JNZ     ?C0052
                                           ; SOURCE LINE # 602
01CB 75A3FF            MOV     SPI0DAT,#0FFH
01CE         ?C0055:
01CE 30FFFD            JNB     SPIF,?C0055
01D1         ?C0056:
01D1 120000      R     LCALL   L?0156
01D4         ?C0057:
01D4 30FFFD            JNB     SPIF,?C0057
01D7         ?C0058:
01D7         ?C0133:
01D7 020000      R     LJMP    ?C0134
                                           ; SOURCE LINE # 603
01DA         ?C0053:
                                           ; SOURCE LINE # 617
01DA 120000      R     LCALL   L?0154
                                           ; SOURCE LINE # 620
01DD 120000      R     LCALL   L?0151
01E0 FC                MOV     R4,A
01E1 A3                INC     DPTR
01E2 E0                MOVX    A,@DPTR
01E3 FD                MOV     R5,A
01E4 120000      E     LCALL   _READ_BYTES
                                           ; SOURCE LINE # 627
01E7 7FFF              MOV     R7,#0FFH
01E9 120000      R     LCALL   _Write_Read_Spi_Byte
01EC 7800        R     MOV     R0,#LOW dummy_CRC
01EE A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 639
01F0 806A              SJMP    ?C0050
                                           ; SOURCE LINE # 640
01F2         ?C0059:
                                           ; SOURCE LINE # 648
01F2 7FFF              MOV     R7,#0FFH
01F4 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 649
01F7 7FFE              MOV     R7,#0FEH
01F9 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 660
01FC 7FBC              MOV     R7,#0BCH
01FE 7E02              MOV     R6,#02H
0200 120000      R     LCALL   _Wait_ns
                                           ; SOURCE LINE # 664
0203 120000      R     LCALL   L?0152
0206 FC                MOV     R4,A
0207 A3                INC     DPTR
0208 E0                MOVX    A,@DPTR
0209 FD                MOV     R5,A
020A 120000      E     LCALL   _WRITE_BYTES
                                           ; SOURCE LINE # 672
020D 7FFF              MOV     R7,#0FFH
020F 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 673
0212 7FFF              MOV     R7,#0FFH
0214 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 683
0217 E4                CLR     A
0218 900000      R     MOV     DPTR,#loopguard
021B F0                MOVX    @DPTR,A
021C         ?C0062:
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 60  

                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 691
021C 7FFF              MOV     R7,#0FFH
021E 120000      R     LCALL   _Write_Read_Spi_Byte
0221 7800        R     MOV     R0,#LOW data_resp
0223 A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 692
0225 900000      R     MOV     DPTR,#loopguard
0228 E0                MOVX    A,@DPTR
0229 04                INC     A
022A F0                MOVX    @DPTR,A
022B 6009              JZ      ?C0061
                                           ; SOURCE LINE # 701
022D         ?C0060:
                                           ; SOURCE LINE # 704
022D 7800        R     MOV     R0,#LOW data_resp
022F E6                MOV     A,@R0
0230 5411              ANL     A,#011H
0232 FF                MOV     R7,A
0233 BF01E6            CJNE    R7,#01H,?C0062
0236         ?C0061:
                                           ; SOURCE LINE # 705
0236 900000      R     MOV     DPTR,#loopguard
0239 E0                MOVX    A,@DPTR
023A 7013              JNZ     ?C0069
023C 75A3FF            MOV     SPI0DAT,#0FFH
023F         ?C0065:
023F 30FFFD            JNB     SPIF,?C0065
0242         ?C0066:
0242 120000      R     LCALL   L?0156
0245         ?C0067:
0245 30FFFD            JNB     SPIF,?C0067
0248         ?C0068:
0248         ?C0134:
0248 C2FF              CLR     SPIF
024A 7EFF              MOV     R6,#0FFH
024C 7FFF              MOV     R7,#0FFH
024E 22                RET     
024F         ?C0069:
                                           ; SOURCE LINE # 712
024F 7FFF              MOV     R7,#0FFH
0251 120000      R     LCALL   _Write_Read_Spi_Byte
0254 EF                MOV     A,R7
0255 60F8              JZ      ?C0069
0257         ?C0070:
                                           ; SOURCE LINE # 713
0257 7FFF              MOV     R7,#0FFH
0259 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 729
                                           ; SOURCE LINE # 730
                                           ; SOURCE LINE # 731
025C         ?C0050:
                                           ; SOURCE LINE # 738
025C 7FFF              MOV     R7,#0FFH
025E 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 739
0261 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 740
0263 7FFF              MOV     R7,#0FFH
0265 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 753
0268 7800        R     MOV     R0,#LOW current_command
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 61  

026A E6                MOV     A,@R0
026B FF                MOV     R7,A
026C 6409              XRL     A,#09H
026E 6004              JZ      ?C0073
0270 EF                MOV     A,R7
0271 B40A06            CJNE    A,#0AH,?C0072
0274         ?C0073:
                                           ; SOURCE LINE # 754
                                           ; SOURCE LINE # 755
0274 900000      R     MOV     DPTR,#old_blklen
0277 120000      R     LCALL   L?0162
                                           ; SOURCE LINE # 756
027A         ?C0072:
                                           ; SOURCE LINE # 757
027A 7800        R     MOV     R0,#LOW card_response
027C E6                MOV     A,@R0
027D FE                MOV     R6,A
027E 08                INC     R0
027F E6                MOV     A,@R0
0280 FF                MOV     R7,A
                                           ; SOURCE LINE # 758
0281         ?C0018:
0281 22                RET     
0282         L?0140:
0282 7FFF              MOV     R7,#0FFH
0284 120000      R     LCALL   _Write_Read_Spi_Byte
0287 7800        R     MOV     R0,#LOW card_response
0289 A607              MOV     @R0,AR7
028B 900000      R     MOV     DPTR,#loopguard
028E E0                MOVX    A,@DPTR
028F 04                INC     A
0290 F0                MOVX    @DPTR,A
0291 22                RET     
0292         L?0147:
0292 7FFF              MOV     R7,#0FFH
0294 120000      R     LCALL   _Write_Read_Spi_Byte
0297 7800        R     MOV     R0,#LOW card_response
0299 A607              MOV     @R0,AR7
029B 900000      R     MOV     DPTR,#loopguard
029E E0                MOVX    A,@DPTR
029F 04                INC     A
02A0 F0                MOVX    @DPTR,A
02A1 22                RET     
02A2         L?0165:
02A2 7FBC              MOV     R7,#0BCH
02A4 7E02              MOV     R6,#02H
02A6 120000      R     LCALL   _Wait_ns
02A9 22                RET     
02AA         L?0170:
02AA 7FFF              MOV     R7,#0FFH
02AC 120000      R     LCALL   _Write_Read_Spi_Byte
02AF EF                MOV     A,R7
02B0 22                RET     
             ; FUNCTION _MMC_Command_Exec (END)

             ; FUNCTION MMC_FLASH_Init (BEGIN)
                                           ; SOURCE LINE # 770
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 776
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#counter
0004 F0                MOVX    @DPTR,A
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 62  

                                           ; SOURCE LINE # 787
0005 120000      R     LCALL   SPI_Init
                                           ; SOURCE LINE # 788
0008 7F64              MOV     R7,#064H
000A FE                MOV     R6,A
000B 120000      R     LCALL   _Wait_ms
                                           ; SOURCE LINE # 789
000E 900000      R     MOV     DPTR,#pchar
0011 7400        R     MOV     A,#HIGH LOCAL_BLOCK
0013 F0                MOVX    @DPTR,A
0014 A3                INC     DPTR
0015 7400        R     MOV     A,#LOW LOCAL_BLOCK
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 790
0018 E4                CLR     A
0019 900000      R     MOV     DPTR,#counter
001C F0                MOVX    @DPTR,A
001D         ?C0074:
                                           ; SOURCE LINE # 795
                                           ; SOURCE LINE # 802
001D 120000      R     LCALL   L?0160
0020 9408              SUBB    A,#08H
0022 40F9              JC      ?C0074
0024         ?C0075:
                                           ; SOURCE LINE # 803
0024 E4                CLR     A
0025 900000      R     MOV     DPTR,#counter
0028 F0                MOVX    @DPTR,A
0029         ?C0077:
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 815
0029 120000      R     LCALL   L?0160
002C 9402              SUBB    A,#02H
002E 40F9              JC      ?C0077
0030         ?C0078:
                                           ; SOURCE LINE # 820
0030 C2FA              CLR     NSSMD0
                                           ; SOURCE LINE # 827
0032 120000      R     LCALL   L?0166
                                           ; SOURCE LINE # 828
0035 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
0038 120000      E     LCALL   ?C?LSTKXDATA
003B 00                DB      00H
003C 00                DB      00H
003D 00                DB      00H
003E 00                DB      00H
003F 120000      R     LCALL   L?0137
0042 E4                CLR     A
0043 FF                MOV     R7,A
0044 120000      R     LCALL   L?0141
                                           ; SOURCE LINE # 830
0047 120000      R     LCALL   L?0163
004A         ?C0082:
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 836
004A 120000      R     LCALL   L?0166
                                           ; SOURCE LINE # 837
004D 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
0050 120000      E     LCALL   ?C?LSTKXDATA
0053 00                DB      00H
0054 00                DB      00H
0055 00                DB      00H
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 63  

0056 00                DB      00H
0057 120000      R     LCALL   L?0137
005A 7F01              MOV     R7,#01H
005C 120000      R     LCALL   L?0141
                                           ; SOURCE LINE # 838
005F 120000      R     LCALL   L?0142
0062 45F0              ORL     A,B
0064 6007              JZ      ?C0081
                                           ; SOURCE LINE # 839
0066         ?C0080:
0066 900000      R     MOV     DPTR,#card_status
0069 E0                MOVX    A,@DPTR
006A 20E0DD            JB      ACC.0,?C0082
006D         ?C0081:
                                           ; SOURCE LINE # 840
006D 7BFF              MOV     R3,#0FFH
006F 7A00        R     MOV     R2,#HIGH ?SC_0
0071 7900        R     MOV     R1,#LOW ?SC_0
0073 900000      R     MOV     DPTR,#loopguard
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 A3                INC     DPTR
0079 E0                MOVX    A,@DPTR
007A 900000      E     MOV     DPTR,#?_printf?BYTE+03H
007D CF                XCH     A,R7
007E F0                MOVX    @DPTR,A
007F A3                INC     DPTR
0080 EF                MOV     A,R7
0081 F0                MOVX    @DPTR,A
0082 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 842
0085 900000      R     MOV     DPTR,#loopguard
0088 E0                MOVX    A,@DPTR
0089 7002              JNZ     ?C0124
008B A3                INC     DPTR
008C E0                MOVX    A,@DPTR
008D         ?C0124:
008D 7003              JNZ     $ + 5H
008F 020000      R     LJMP    ?C0085
0092         ?C0084:
                                           ; SOURCE LINE # 849
0092 7FFF              MOV     R7,#0FFH
0094 120000      R     LCALL   _Write_Read_Spi_Byte
                                           ; SOURCE LINE # 856
0097 120000      R     LCALL   L?0163
009A         ?C0088:
                                           ; SOURCE LINE # 859
                                           ; SOURCE LINE # 860
009A 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
009D 120000      E     LCALL   ?C?LSTKXDATA
00A0 00                DB      00H
00A1 00                DB      00H
00A2 00                DB      00H
00A3 00                DB      00H
00A4 120000      R     LCALL   L?0157
00A7 AA06              MOV     R2,AR6
00A9 F9                MOV     R1,A
00AA 7B01              MOV     R3,#01H
00AC 120000      R     LCALL   L?0139
00AF 7F17              MOV     R7,#017H
00B1 120000      R     LCALL   L?0145
                                           ; SOURCE LINE # 861
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 64  

00B4 120000      R     LCALL   L?0142
00B7 45F0              ORL     A,B
00B9 600B              JZ      ?C0087
                                           ; SOURCE LINE # 862
00BB         ?C0086:
00BB 120000      R     LCALL   L?0157
00BE F582              MOV     DPL,A
00C0 8E83              MOV     DPH,R6
00C2 E0                MOVX    A,@DPTR
00C3 30E7D4            JNB     ACC.7,?C0088
00C6         ?C0087:
                                           ; SOURCE LINE # 863
00C6 900000      R     MOV     DPTR,#loopguard
00C9 E0                MOVX    A,@DPTR
00CA 7002              JNZ     ?C0125
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE         ?C0125:
00CE 7003              JNZ     $ + 5H
00D0 020000      R     LJMP    ?C0085
00D3         ?C0090:
                                           ; SOURCE LINE # 865
00D3 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
00D6 120000      E     LCALL   ?C?LSTKXDATA
00D9 00                DB      00H
00DA 00                DB      00H
00DB 00                DB      00H
00DC 00                DB      00H
00DD 120000      R     LCALL   L?0138
00E0 7F05              MOV     R7,#05H
00E2 120000      R     LCALL   L?0145
                                           ; SOURCE LINE # 869
00E5 E4                CLR     A
00E6 900000      R     MOV     DPTR,#i
00E9 F0                MOVX    @DPTR,A
00EA A3                INC     DPTR
00EB F0                MOVX    @DPTR,A
00EC         ?C0091:
00EC 120000      R     LCALL   L?0148
00EF 9404              SUBB    A,#04H
00F1 EE                MOV     A,R6
00F2 6480              XRL     A,#080H
00F4 9480              SUBB    A,#080H
00F6 5005              JNC     ?C0092
                                           ; SOURCE LINE # 870
                                           ; SOURCE LINE # 871
00F8 120000      R     LCALL   L?0135
00FB 80EF              SJMP    ?C0091
00FD         ?C0092:
                                           ; SOURCE LINE # 873
00FD 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
0100 120000      E     LCALL   ?C?LSTKXDATA
0103 00                DB      00H
0104 00                DB      00H
0105 00                DB      00H
0106 00                DB      00H
0107 120000      R     LCALL   L?0158
010A AA06              MOV     R2,AR6
010C F9                MOV     R1,A
010D 7B01              MOV     R3,#01H
010F 120000      R     LCALL   L?0139
0112 7F02              MOV     R7,#02H
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 65  

0114 120000      R     LCALL   L?0167
                                           ; SOURCE LINE # 875
0117 900000      R     MOV     DPTR,#card_status
011A E0                MOVX    A,@DPTR
011B 7002              JNZ     ?C0126
011D A3                INC     DPTR
011E E0                MOVX    A,@DPTR
011F         ?C0126:
011F 7026              JNZ     ?C0094
                                           ; SOURCE LINE # 876
0121 7BFF              MOV     R3,#0FFH
0123 7A00        R     MOV     R2,#HIGH ?SC_33
0125 7900        R     MOV     R1,#LOW ?SC_33
                                           ; SOURCE LINE # 877
0127 120000      R     LCALL   L?0159
012A         ?C0095:
012A 120000      R     LCALL   L?0148
012D 9410              SUBB    A,#010H
012F EE                MOV     A,R6
0130 6480              XRL     A,#080H
0132 9480              SUBB    A,#080H
0134 5005              JNC     ?C0096
                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 879
0136 120000      R     LCALL   L?0135
0139 80EF              SJMP    ?C0095
013B         ?C0096:
                                           ; SOURCE LINE # 883
013B 75A201            MOV     SPI0CKR,#01H
                                           ; SOURCE LINE # 885
013E 7F01              MOV     R7,#01H
0140 7E00              MOV     R6,#00H
0142 120000      R     LCALL   _Wait_ms
                                           ; SOURCE LINE # 886
0145 8058              SJMP    ?C0098
0147         ?C0094:
                                           ; SOURCE LINE # 887
0147 7BFF              MOV     R3,#0FFH
0149 7A00        R     MOV     R2,#HIGH ?SC_46
014B 7900        R     MOV     R1,#LOW ?SC_46
014D 900000      R     MOV     DPTR,#card_status
0150 E0                MOVX    A,@DPTR
0151 FF                MOV     R7,A
0152 A3                INC     DPTR
0153 E0                MOVX    A,@DPTR
0154 900000      E     MOV     DPTR,#?_printf?BYTE+03H
0157 CF                XCH     A,R7
0158 F0                MOVX    @DPTR,A
0159 A3                INC     DPTR
015A EF                MOV     A,R7
015B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 888
015C 120000      R     LCALL   L?0159
015F         ?C0099:
015F 120000      R     LCALL   L?0149
0162 9410              SUBB    A,#010H
0164 EE                MOV     A,R6
0165 6480              XRL     A,#080H
0167 9480              SUBB    A,#080H
0169 5024              JNC     ?C0100
                                           ; SOURCE LINE # 889
016B 7BFF              MOV     R3,#0FFH
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 66  

016D 7A00        R     MOV     R2,#HIGH ?SC_24
016F 7900        R     MOV     R1,#LOW ?SC_24
0171 900000      R     MOV     DPTR,#pchar
0174 E0                MOVX    A,@DPTR
0175 FC                MOV     R4,A
0176 A3                INC     DPTR
0177 E0                MOVX    A,@DPTR
0178 2F                ADD     A,R7
0179 F582              MOV     DPL,A
017B EC                MOV     A,R4
017C 3E                ADDC    A,R6
017D F583              MOV     DPH,A
017F E0                MOVX    A,@DPTR
0180 900000      E     MOV     DPTR,#?_printf?BYTE+03H
0183 F0                MOVX    @DPTR,A
0184 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 890
0187 900000      R     MOV     DPTR,#i
018A 120000      R     LCALL   L?0144
018D 80D0              SJMP    ?C0099
018F         ?C0100:
                                           ; SOURCE LINE # 891
018F 900000      R     MOV     DPTR,#PHYSICAL_BLOCKS
0192 120000      E     LCALL   ?C?LSTKXDATA
0195 00                DB      00H
0196 00                DB      00H
0197 00                DB      00H
0198 00                DB      00H
                                           ; SOURCE LINE # 892
0199 120000      R     LCALL   L?0146
019C 020000      E     LJMP    ?C?LSTXDATA
                                           ; SOURCE LINE # 894
019F         ?C0098:
                                           ; SOURCE LINE # 896
019F 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
01A2 120000      E     LCALL   ?C?LSTKXDATA
01A5 00                DB      00H
01A6 00                DB      00H
01A7 02                DB      02H
01A8 00                DB      00H
01A9 120000      R     LCALL   L?0138
01AC 7F06              MOV     R7,#06H
01AE 120000      R     LCALL   L?0167
                                           ; SOURCE LINE # 898
01B1 900000      R     MOV     DPTR,#pchar
01B4 E0                MOVX    A,@DPTR
01B5 FC                MOV     R4,A
01B6 A3                INC     DPTR
01B7 E0                MOVX    A,@DPTR
01B8 FD                MOV     R5,A
01B9 2405              ADD     A,#05H
01BB F582              MOV     DPL,A
01BD E4                CLR     A
01BE 3C                ADDC    A,R4
01BF F583              MOV     DPH,A
01C1 E0                MOVX    A,@DPTR
01C2 540F              ANL     A,#0FH
01C4 FF                MOV     R7,A
01C5 7401              MOV     A,#01H
01C7 7E00              MOV     R6,#00H
01C9 A807              MOV     R0,AR7
01CB 08                INC     R0
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 67  

01CC 8005              SJMP    ?C0128
01CE         ?C0127:
01CE C3                CLR     C
01CF 33                RLC     A
01D0 CE                XCH     A,R6
01D1 33                RLC     A
01D2 CE                XCH     A,R6
01D3         ?C0128:
01D3 D8F9              DJNZ    R0,?C0127
01D5 900000      R     MOV     DPTR,#bl_len+01H
01D8 F0                MOVX    @DPTR,A
01D9 EE                MOV     A,R6
01DA 900000      R     MOV     DPTR,#bl_len
01DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 899
01DE ED                MOV     A,R5
01DF 2406              ADD     A,#06H
01E1 F582              MOV     DPL,A
01E3 E4                CLR     A
01E4 3C                ADDC    A,R4
01E5 F583              MOV     DPH,A
01E7 E0                MOVX    A,@DPTR
01E8 5403              ANL     A,#03H
01EA 25E0              ADD     A,ACC
01EC 25E0              ADD     A,ACC
01EE FC                MOV     R4,A
01EF 900000      R     MOV     DPTR,#pchar
01F2 E0                MOVX    A,@DPTR
01F3 FA                MOV     R2,A
01F4 A3                INC     DPTR
01F5 E0                MOVX    A,@DPTR
01F6 FB                MOV     R3,A
01F7 2407              ADD     A,#07H
01F9 F582              MOV     DPL,A
01FB E4                CLR     A
01FC 3A                ADDC    A,R2
01FD F583              MOV     DPH,A
01FF E0                MOVX    A,@DPTR
0200 75F004            MOV     B,#04H
0203 A4                MUL     AB
0204 FF                MOV     R7,A
0205 EC                MOV     A,R4
0206 45F0              ORL     A,B
0208 FE                MOV     R6,A
0209 EB                MOV     A,R3
020A 2408              ADD     A,#08H
020C F582              MOV     DPL,A
020E E4                CLR     A
020F 3A                ADDC    A,R2
0210 F583              MOV     DPH,A
0212 E0                MOVX    A,@DPTR
0213 54C0              ANL     A,#0C0H
0215 C4                SWAP    A
0216 13                RRC     A
0217 13                RRC     A
0218 5403              ANL     A,#03H
021A FD                MOV     R5,A
021B EF                MOV     A,R7
021C 4D                ORL     A,R5
;---- Variable 'c_size' assigned to Register 'R2/R3' ----
021D FB                MOV     R3,A
021E AA06              MOV     R2,AR6
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 68  

                                           ; SOURCE LINE # 901
0220 120000      R     LCALL   L?0158
0223 FF                MOV     R7,A
0224 2409              ADD     A,#09H
0226 F582              MOV     DPL,A
0228 E4                CLR     A
0229 3E                ADDC    A,R6
022A F583              MOV     DPH,A
022C E0                MOVX    A,@DPTR
022D 5403              ANL     A,#03H
022F 25E0              ADD     A,ACC
0231 FD                MOV     R5,A
0232 EF                MOV     A,R7
0233 240A              ADD     A,#0AH
0235 F582              MOV     DPL,A
0237 E4                CLR     A
0238 3E                ADDC    A,R6
0239 F583              MOV     DPH,A
023B E0                MOVX    A,@DPTR
023C 5480              ANL     A,#080H
023E C4                SWAP    A
023F 13                RRC     A
0240 13                RRC     A
0241 13                RRC     A
0242 5401              ANL     A,#01H
0244 4D                ORL     A,R5
0245 900000      R     MOV     DPTR,#c_mult
0248 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 904
0249 AE02              MOV     R6,AR2
024B AF03              MOV     R7,AR3
024D EF                MOV     A,R7
024E 2401              ADD     A,#01H
0250 FF                MOV     R7,A
0251 E4                CLR     A
0252 3E                ADDC    A,R6
0253 FE                MOV     R6,A
0254 E4                CLR     A
0255 FC                MOV     R4,A
0256 FD                MOV     R5,A
0257 C004              PUSH    AR4
0259 C005              PUSH    AR5
025B C006              PUSH    AR6
025D C007              PUSH    AR7
025F E0                MOVX    A,@DPTR
0260 2402              ADD     A,#02H
0262 FF                MOV     R7,A
0263 7401              MOV     A,#01H
0265 7E00              MOV     R6,#00H
0267 A807              MOV     R0,AR7
0269 08                INC     R0
026A 8005              SJMP    ?C0130
026C         ?C0129:
026C C3                CLR     C
026D 33                RLC     A
026E CE                XCH     A,R6
026F 33                RLC     A
0270 CE                XCH     A,R6
0271         ?C0130:
0271 D8F9              DJNZ    R0,?C0129
0273 FF                MOV     R7,A
0274 EE                MOV     A,R6
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 69  

0275 33                RLC     A
0276 95E0              SUBB    A,ACC
0278 FD                MOV     R5,A
0279 FC                MOV     R4,A
027A D003              POP     AR3
027C D002              POP     AR2
027E D001              POP     AR1
0280 D000              POP     AR0
0282 120000      E     LCALL   ?C?LMUL
0285 900000      R     MOV     DPTR,#PHYSICAL_BLOCKS
0288 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 905
028B 120000      R     LCALL   L?0146
028E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 907
0291 120000      R     LCALL   L?0164
0294         ?C0102:
                                           ; SOURCE LINE # 909
0294 7B01              MOV     R3,#01H
0296 7A00        E     MOV     R2,#HIGH Scratch
0298 7900        E     MOV     R1,#LOW Scratch
029A 7F00              MOV     R7,#00H
029C 7E00              MOV     R6,#00H
029E 7D00              MOV     R5,#00H
02A0 7C00              MOV     R4,#00H
02A2 120000      R     LCALL   _MMC_FLASH_Block_Read
02A5 EF                MOV     A,R7
02A6 4E                ORL     A,R6
02A7 6007              JZ      ?C0103
                                           ; SOURCE LINE # 910
02A9 120000      R     LCALL   L?0143
02AC 45F0              ORL     A,B
02AE 70E4              JNZ     ?C0102
                                           ; SOURCE LINE # 911
02B0         ?C0103:
                                           ; SOURCE LINE # 914
02B0 D200        R     SETB    Is_Initialized
                                           ; SOURCE LINE # 916
02B2 C2A2              CLR     Led1
02B4 C2A3              CLR     Led2
                                           ; SOURCE LINE # 917
02B6         ?C0085:
02B6 22                RET     
02B7         L?0135:
02B7 7BFF              MOV     R3,#0FFH
02B9 7A00        R     MOV     R2,#HIGH ?SC_24
02BB 7900        R     MOV     R1,#LOW ?SC_24
02BD 900000      R     MOV     DPTR,#pchar
02C0 E0                MOVX    A,@DPTR
02C1 FC                MOV     R4,A
02C2 A3                INC     DPTR
02C3 E0                MOVX    A,@DPTR
02C4 2F                ADD     A,R7
02C5 F582              MOV     DPL,A
02C7 EC                MOV     A,R4
02C8 3E                ADDC    A,R6
02C9 F583              MOV     DPH,A
02CB E0                MOVX    A,@DPTR
02CC 900000      E     MOV     DPTR,#?_printf?BYTE+03H
02CF F0                MOVX    @DPTR,A
02D0 120000      E     LCALL   _printf
02D3 900000      R     MOV     DPTR,#i
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 70  

02D6 E4                CLR     A
02D7 75F001            MOV     B,#01H
02DA 120000      E     LCALL   ?C?IILDX
02DD 22                RET     
02DE         L?0141:
02DE 120000      R     LCALL   _MMC_Command_Exec
02E1 900000      R     MOV     DPTR,#card_status
02E4 EE                MOV     A,R6
02E5 F0                MOVX    @DPTR,A
02E6 A3                INC     DPTR
02E7 EF                MOV     A,R7
02E8 F0                MOVX    @DPTR,A
02E9 22                RET     
02EA         L?0145:
02EA 120000      R     LCALL   _MMC_Command_Exec
02ED 900000      R     MOV     DPTR,#card_status
02F0 EE                MOV     A,R6
02F1 F0                MOVX    @DPTR,A
02F2 A3                INC     DPTR
02F3 EF                MOV     A,R7
02F4 F0                MOVX    @DPTR,A
02F5 22                RET     
02F6         L?0159:
02F6 120000      E     LCALL   _printf
02F9 E4                CLR     A
02FA 900000      R     MOV     DPTR,#i
02FD F0                MOVX    @DPTR,A
02FE A3                INC     DPTR
02FF F0                MOVX    @DPTR,A
0300 22                RET     
0301         L?0160:
0301 7FFF              MOV     R7,#0FFH
0303 120000      R     LCALL   _Write_Read_Spi_Byte
0306 900000      R     MOV     DPTR,#counter
0309 E0                MOVX    A,@DPTR
030A 04                INC     A
030B F0                MOVX    @DPTR,A
030C E0                MOVX    A,@DPTR
030D C3                CLR     C
030E 22                RET     
030F         L?0166:
030F 7F01              MOV     R7,#01H
0311 7E00              MOV     R6,#00H
0313 120000      R     LCALL   _Wait_ms
0316 22                RET     
0317         L?0167:
0317 120000      R     LCALL   _MMC_Command_Exec
031A 900000      R     MOV     DPTR,#card_status
031D EE                MOV     A,R6
031E F0                MOVX    @DPTR,A
031F A3                INC     DPTR
0320 EF                MOV     A,R7
0321 F0                MOVX    @DPTR,A
0322 22                RET     
             ; FUNCTION MMC_FLASH_Init (END)

             ; FUNCTION _MMC_FLASH_Block_Read (BEGIN)
                                           ; SOURCE LINE # 931
0000 900000      R     MOV     DPTR,#address
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#pchar
0009 120000      E     LCALL   ?C?PSTXDATA
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 71  

                                           ; SOURCE LINE # 932
                                           ; SOURCE LINE # 934
000C 900000      R     MOV     DPTR,#address
000F 120000      R     LCALL   L?0161
0012 900000      R     MOV     DPTR,#address
0015 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 935
0018 D2A2              SETB    Led1
                                           ; SOURCE LINE # 942
001A 900000      R     MOV     DPTR,#address
001D 120000      R     LCALL   L?0169
0020 900000      R     MOV     DPTR,#pchar
0023 120000      E     LCALL   ?C?PLDXDATA
0026 120000      R     LCALL   L?0139
0029 7F07              MOV     R7,#07H
002B 120000      R     LCALL   _MMC_Command_Exec
;---- Variable 'card_status' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 947
002E C2A2              CLR     Led1
                                           ; SOURCE LINE # 948
                                           ; SOURCE LINE # 949
0030         ?C0105:
0030 22                RET     
             ; FUNCTION _MMC_FLASH_Block_Read (END)

             ; FUNCTION _MMC_FLASH_Block_Write (BEGIN)
                                           ; SOURCE LINE # 965
0000 900000      R     MOV     DPTR,#address
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#wdata
0009 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 966
                                           ; SOURCE LINE # 969
000C 900000      R     MOV     DPTR,#address
000F 120000      R     LCALL   L?0161
0012 900000      R     MOV     DPTR,#address
0015 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 970
0018 D2A3              SETB    Led2
                                           ; SOURCE LINE # 971
001A 900000      R     MOV     DPTR,#address
001D 120000      R     LCALL   L?0169
0020 900000      R     MOV     DPTR,#wdata
0023 120000      E     LCALL   ?C?PLDXDATA
0026 120000      R     LCALL   L?0139
0029 7F09              MOV     R7,#09H
002B 120000      R     LCALL   _MMC_Command_Exec
;---- Variable 'card_status' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 972
002E C2A3              CLR     Led2
                                           ; SOURCE LINE # 973
                                           ; SOURCE LINE # 974
0030         ?C0106:
0030 22                RET     
             ; FUNCTION _MMC_FLASH_Block_Write (END)

             ; FUNCTION _Write_Read_Spi_Byte (BEGIN)
                                           ; SOURCE LINE # 1021
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1024
0000 8FA3              MOV     SPI0DAT,R7
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 72  

0002         ?C0107:
                                           ; SOURCE LINE # 1025
0002 30FFFD            JNB     SPIF,?C0107
0005         ?C0108:
                                           ; SOURCE LINE # 1026
0005 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 1027
;---- Variable 'ret' assigned to Register 'R7' ----
0007 AFA3              MOV     R7,SPI0DAT
                                           ; SOURCE LINE # 1028
                                           ; SOURCE LINE # 1029
0009         ?C0109:
0009 22                RET     
             ; FUNCTION _Write_Read_Spi_Byte (END)

             ; FUNCTION _Wait_ms (BEGIN)
                                           ; SOURCE LINE # 1043
0000 900000      R     MOV     DPTR,#count
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1044
                                           ; SOURCE LINE # 1046
0008 E4                CLR     A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C F0                MOVX    @DPTR,A
000D         ?C0110:
000D 900000      R     MOV     DPTR,#count
0010 120000      R     LCALL   L?0150
0013 900000      R     MOV     DPTR,#i+01H
0016 E0                MOVX    A,@DPTR
0017 9F                SUBB    A,R7
0018 900000      R     MOV     DPTR,#i
001B E0                MOVX    A,@DPTR
001C 9E                SUBB    A,R6
001D 502D              JNC     ?C0116
                                           ; SOURCE LINE # 1047
001F E4                CLR     A
0020 900000      R     MOV     DPTR,#j
0023 F0                MOVX    @DPTR,A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
0026         ?C0113:
                                           ; SOURCE LINE # 1048
0026 7FE8              MOV     R7,#0E8H
0028 7E03              MOV     R6,#03H
002A 120000      R     LCALL   _Wait_ns
                                           ; SOURCE LINE # 1049
002D 900000      R     MOV     DPTR,#j
0030 120000      R     LCALL   L?0144
0033 C3                CLR     C
0034 900000      R     MOV     DPTR,#j+01H
0037 E0                MOVX    A,@DPTR
0038 94E8              SUBB    A,#0E8H
003A 900000      R     MOV     DPTR,#j
003D E0                MOVX    A,@DPTR
003E 6480              XRL     A,#080H
0040 9483              SUBB    A,#083H
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 73  

0042 40E2              JC      ?C0113
                                           ; SOURCE LINE # 1050
0044         ?C0112:
0044 900000      R     MOV     DPTR,#i
0047 120000      R     LCALL   L?0144
004A 80C1              SJMP    ?C0110
                                           ; SOURCE LINE # 1051
004C         ?C0116:
004C 22                RET     
             ; FUNCTION _Wait_ms (END)

             ; FUNCTION _Wait_ns (BEGIN)
                                           ; SOURCE LINE # 1063
;---- Variable 'count' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1064
                                           ; SOURCE LINE # 1069
0000 7C00              MOV     R4,#00H
0002 7D14              MOV     R5,#014H
0004 120000      E     LCALL   ?C?UIDIV
0007         ?C0117:
                                           ; SOURCE LINE # 1072
0007 EF                MOV     A,R7
0008 1F                DEC     R7
0009 AC06              MOV     R4,AR6
000B 7001              JNZ     ?C0131
000D 1E                DEC     R6
000E         ?C0131:
000E 4C                ORL     A,R4
000F 70F6              JNZ     ?C0117
                                           ; SOURCE LINE # 1073
0011         ?C0119:
0011 22                RET     
             ; FUNCTION _Wait_ns (END)

             ; FUNCTION Get_Status_MMC (BEGIN)
                                           ; SOURCE LINE # 1086
                                           ; SOURCE LINE # 1087
                                           ; SOURCE LINE # 1088
0000 900000      R     MOV     DPTR,#?_MMC_Command_Exec?BYTE+01H
0003 120000      E     LCALL   ?C?LSTKXDATA
0006 00                DB      00H
0007 00                DB      00H
0008 00                DB      00H
0009 00                DB      00H
000A 120000      R     LCALL   L?0138
000D 7F05              MOV     R7,#05H
000F 120000      R     LCALL   _MMC_Command_Exec
;---- Variable 'status' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1089
0012 7BFF              MOV     R3,#0FFH
0014 7A00        R     MOV     R2,#HIGH ?SC_67
0016 7900        R     MOV     R1,#LOW ?SC_67
0018 900000      E     MOV     DPTR,#?_printf?BYTE+03H
001B EE                MOV     A,R6
001C F0                MOVX    @DPTR,A
001D A3                INC     DPTR
001E EF                MOV     A,R7
001F F0                MOVX    @DPTR,A
0020 020000      E     LJMP    _printf
             ; FUNCTION Get_Status_MMC (END)

C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 74  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
PHYSICAL_BLOCKS. . . . . . . . . . . .  PUBLIC   XDATA  U_LONG   0002H  4
COMMAND. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  command_byte . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  arg_required . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CRC. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  trans_type . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  response . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  var_length . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
command_list . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    005AH  150
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
ULONG. . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  l. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
Is_Initialized . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
MMC_FLASH_Init . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  loopguard. . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0002H  2
  card_status. . . . . . . . . . . . .  AUTO     XDATA  UNION    0004H  2
  counter. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
  pchar. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0007H  2
  c_size . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
  bl_len . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0009H  2
  c_mult . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000BH  1
SPI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
LONG . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  l. . . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
LONG . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  l. . . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SPIF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
NSSMD0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
_Wait_ms . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  count. . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0002H  2
  j. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0004H  2
_Wait_ns . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  count. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
LOCAL_BLOCK. . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0006H  16
_MMC_FLASH_Block_Read. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  pchar. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  card_status. . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  i. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  c. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UINT . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  i. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
Led1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
Led2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
C51 COMPILER V8.02   F34X_MSD_MMC                  07/24/2007 22:07:37 PAGE 75  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


Get_Status_MMC . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  status . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
_MMC_Command_Exec. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  cmd_loc. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  argument . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0001H  4
  pchar. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0005H  3
  loopguard. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0008H  1
  current_command. . . . . . . . . . .  AUTO     IDATA  STRUCT   0000H  6
  long_arg . . . . . . . . . . . . . .  AUTO     IDATA  UNION    0006H  4
  current_blklen . . . . . . . . . . .  STATIC   XDATA  U_INT    0000H  2
  old_blklen . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0009H  4
  counter. . . . . . . . . . . . . . .  AUTO     IDATA  U_INT    000AH  2
  card_response. . . . . . . . . . . .  AUTO     IDATA  UNION    000CH  2
  data_resp. . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   000EH  1
  dummy_CRC. . . . . . . . . . . . . .  AUTO     IDATA  U_CHAR   000FH  1
  plast. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      000DH  3
_MMC_FLASH_Block_Write . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  wdata. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  card_status. . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
Scratch. . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  512
_Write_Read_Spi_Byte . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_WRITE_BYTES . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SPI_Init . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_READ_BYTES. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
INT. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  i. . . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
INT. . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  i. . . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  b. . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
_printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
PHYSICAL_SIZE. . . . . . . . . . . . .  PUBLIC   XDATA  U_LONG   0016H  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1886    ----
   CONSTANT SIZE    =    240    ----
   XDATA SIZE       =     26      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----      16
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
